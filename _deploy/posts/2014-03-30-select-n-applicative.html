<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Badness 10.000 - On applicative functors and the n+1 selects problem</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/pandoc.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Badness 10.000</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>On applicative functors and the n+1 selects problem</h1>

            <div class="info">
    Posted on March 30, 2014
    
</div>

<p>I recently read a post by <a href="http://ocharles.org.uk/blog/posts/2014-03-24-queries-in-loops-without-a-care-in-the-world.html">ocharles</a> where he creates a Haskell DSL that allows writing queries on the form</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> entities <span class="ot">&lt;-</span> getAllEntities
   expandedEntities <span class="ot">&lt;-</span> for entities <span class="fu">$</span> \entity <span class="ot">-&gt;</span> <span class="kw">do</span>
     entityType  <span class="ot">&lt;-</span> getEntityTypeById (entityTypeId entity)
     entityOwner <span class="ot">&lt;-</span> getEntityOwnerById (entityOwnerId entity)
     return <span class="fu">$</span> <span class="dt">ExpandedEntity</span> entity entityType entityOwner

   doSomething expandedEntities</code></pre>
<p>in such a way that lets us create a single query for running e.g. on a database. Even though the functions <code>getEntityTypeById</code> and <code>getEntityOwnerById</code> are queries themselves, we'd like to reuse the data from the <code>getAllEntities</code> query.</p>
<p>If the semantics of this monad was just something like IO, we'd end up querying multiple times, meaning we'd end up with an instance of the n+1 selects problem.</p>
<p>To solve this problem ocharles presents a somewhat complicated solution using the <code>MVar</code> concurrency primitvies and end with a challenge to find a more &quot;haskelly&quot; solution. I'm going to take a stab at this here. You might want to read ocharles' post to better understand the problem definition and his solution before continuing.</p>
<p>We'll start off with what I call the <code>Annotated</code> applicative functor, which I've <a href="http://www.jayway.com/2014/02/25/cqrs-in-haskell-command-validation-with-applicative-functors/">blogged about previously</a> for it's use in validation.</p>
<p>It's simple definition is as follows</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Annotated</span> f w a <span class="fu">=</span> <span class="dt">Annotated</span> (f a) w 
  <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">instance</span> 
   (<span class="dt">Applicative</span> f, <span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Annotated</span> f w) 
  <span class="kw">where</span>
    pure a <span class="fu">=</span> <span class="dt">Annotated</span> (pure a) mempty
    <span class="dt">Annotated</span> f w <span class="fu">&lt;*&gt;</span> <span class="dt">Annotated</span> a w' <span class="fu">=</span> 
      <span class="dt">Annotated</span> (f <span class="fu">&lt;*&gt;</span> a) (w <span class="fu">&lt;&gt;</span> w')</code></pre>
<p>As you can see, it basically allows us to write our code such that it executes in two &quot;parallel universes&quot;. One which is an effectful applicative in <code>f</code>, and one that is a pure computation as a catenation in the monoid <code>w</code>.</p>
<p>The nice thing about this abstraction is that it lets us examine the result of the pure computation before executing the effects of <code>f</code>. (Or, as in my post on validation, not execute them at all if validation fails).</p>
<p>In order to model queries such as <code>getEntityOwnerById</code>, we also need some notion of an environment containing the result of any executed queries, though we need to be able to defer actually providing that environment until later, but still let these queries &quot;pretend&quot; to return a result. This is exactly what we achieve by wrapping our applicative in a <code>ReaderT</code> with e.g. a map <code>Map k v</code> as the environment.</p>
<p>As the monoid for <code>Annotated</code> we will just choose <code>[k]</code> to collect the keys we will inspect. We'll also assume we want to use some effects. Like ocharles we'll assume failure of queries is a possibility, so we can choose <code>MaybeT IO</code> as the base Monad. Putting these requirements together we get the type</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Query</span> k v a <span class="fu">=</span> <span class="dt">Annotated</span> (<span class="dt">ReaderT</span> (<span class="dt">M.Map</span> k v) (<span class="dt">MaybeT</span> <span class="dt">IO</span>)) [k] a</code></pre>
<p>Let's write some functions for basic operations.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withQuery ::</span> ([k] <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">M.Map</span> k v)) <span class="ot">-&gt;</span> <span class="dt">Query</span> k v a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)
withQuery query (<span class="dt">Annotated</span> f keys) <span class="fu">=</span> <span class="kw">do</span>
  map <span class="ot">&lt;-</span> query keys
  runMaybeT <span class="fu">$</span> runReaderT f map</code></pre>
<p>This just calls function <code>query</code> with the pure part of the computation, to get us the keys. We then run the reader with the resuling map, and unpack the maybe transformer.</p>
<p>Now defining</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">0</span> <span class="st">#</span>
w <span class="st"># f = Annotated f w</span></code></pre>
<p>we can write a generic &quot;getter&quot; for a value at a single key as follows</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getQ ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Query</span> k <span class="dt">Age</span> <span class="dt">Age</span>
getQ id <span class="fu">=</span> 
  [id] <span class="st"># ReaderT $ \map -&gt; MaybeT $ return (M.lookup id map)</span></code></pre>
<p>since <code>liftIO</code> is only defined for monads we provide</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">annotatedLiftIO io <span class="fu">=</span> <span class="dt">Annotated</span> (liftIO io) mempty</code></pre>
<p>Now we can write a &quot;domain-specific&quot; query as follows</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">usersAgeById ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="dt">Id</span> <span class="dt">Age</span> <span class="dt">Age</span>
usersAgeById id 
   <span class="fu">=</span> annotatedLiftIO (putStrLn (<span class="st">&quot;processing user &quot;</span> <span class="fu">++</span> show id))
  <span class="fu">*&gt;</span> getQ id</code></pre>
<p>We'll reuse ocharles definition of <code>getUserAgesById</code></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getUserAgesById ::</span> [<span class="dt">Id</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">M.Map</span> <span class="dt">Id</span> <span class="dt">Age</span>)
getUserAgesById keys <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="fu">$</span> <span class="st">&quot;Looking up &quot;</span> <span class="fu">++</span> show keys
  return <span class="fu">$</span> Map.fromList <span class="fu">$</span> [(<span class="dv">1</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">2</span>)]</code></pre>
<p>...and example (where I've added some output for the &quot;processing&quot;).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">example <span class="fu">=</span> withQuery getUserAgesById <span class="fu">$</span> 
  (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> usersAgeById <span class="dv">1</span> <span class="fu">&lt;*&gt;</span> usersAgeById <span class="dv">2</span></code></pre>
<pre><code>&gt;&gt;&gt; example
Looking up [1,2]
processing user 1
processing user 2
Just 30
</code></pre>
<p>This seems to do the trick nicely. Though perhaps I'm missing something? For further improvements we might choose a better monoid, such as</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">QueryData</span> k <span class="fu">=</span> <span class="dt">Keys</span> [k] <span class="fu">|</span> <span class="dt">AllKeys</span></code></pre>
<p>so that we may run queries over the entire set of keys in a table. It would probably also be nice to write queries over multiple datasets, which I believe could be done with existential types. I think this is one of the things that have been solved by the <a href="http://skillsmatter.com/skillscasts/4429-simon-marlow">Haxl</a> project at Facebook.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
