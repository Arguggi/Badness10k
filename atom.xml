<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Badness 10k - All posts</title>
    <link href="http://philipnilsson.github.io/Badness10k//atom.xml" rel="self" />
    <link href="http://philipnilsson.github.io/Badness10k/" />
    <id>http://philipnilsson.github.io/Badness10k//atom.xml</id>
    <author>
        <name>Philip Nilsson</name>
        <email>alipang@gmail.com</email>
    </author>
    <updated>2016-07-21T00:00:00Z</updated>
    <entry>
    <title>Algebraic patterns - Monoid</title>
    <link href="http://philipnilsson.github.io/Badness10k//posts/2016-07-21-functional-patterns-monoid.html" />
    <id>http://philipnilsson.github.io/Badness10k//posts/2016-07-21-functional-patterns-monoid.html</id>
    <published>2016-07-21T00:00:00Z</published>
    <updated>2016-07-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on July 21, 2016
    
</div>

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<h2 id="definition">Definition</h2>
<p>The <strong>Monoid</strong> pattern is simply the combination of the two patterns <a href="2016-06-29-functional-patterns-identity-element.html">Identity Element</a> and <a href="./2016-07-14-functional-patterns-semigroup.html">Semigroup</a>. A monoid therefore is a datatype with composition <code>⊗</code> and element <code>e</code>, satisfying</p>
<pre><code>x ⊗ e = x
e ⊗ x = x
x ⊗ (y ⊗ z) = (x ⊗ y) ⊗ z</code></pre>
<p>Some understanding of these patterns is assumed in this article. If you feel like you need intuition on what these equations mean, read the entries on these individual patterns before continuing.</p>
<h2 id="intuition">Intuition</h2>
<p>The monoid pattern models the many structures that are semigroups and also have identity elements. In such situations, it is often convenient to consider these patterns in concert in order to derive elegant models and laws.</p>
<p>For instance the semigroup of lists have the empty list <code>[]</code> as identity. Treating lists as a semigroup <em>only</em> often result in less elegant laws where the empty list has to be treated as a separate case.</p>
<p>In this article we’ll give some examples of monoids and develop some models suitable for problem solving in <em>Map-Reduce</em> style programming models.</p>
<h3>
Notation
</h3>
<p>To refer to a particular monoid we take the triple of its type, composition and identity. For instance <code>(Number, +, 0)</code> is the monoid of numbers with addition.</p>
<h3>
Folds
</h3>
<p>For any monoid we can define a function called <code>fold</code>. It takes a list of elements of that monoid to their “product”. For the monoid <code>(Number, +, 0)</code>, we define <code>fold</code> (by example) as</p>
<pre><code>fold([]) = 0
fold([1]) = 1
fold([5, 6, 3, 1])
  = 5 + 6 + 3 + 1
  = 15</code></pre>
<p>The <code>fold</code> function simply inserts the monoid composition (in our case <code>+</code>) between each element. For the empty list it returns the identity element (<code>0</code>). The <code>fold</code> for the monoid <code>(Number, +, 0)</code> then is just the <code>sum</code> function.</p>
<hr>
<p>Let’s repeat the construction above with a different monoid, <code>(Number, max, -∞)</code>. In this case we get</p>
<pre><code>fold([]) = -Infinity
fold([10]) = 10
fold([9, 6, 5, 12])
  = 9 max 6 max 5 max 12
  = 12</code></pre>
<p>so the <code>fold</code> for this monoid is the <code>maximum</code> function which finds the largest element in a list, and returns its identity <code>-∞</code> for the empty list.</p>
<hr>
<p>For the boolean monoid <code>(Bool, &amp;&amp;)</code> <code>fold</code> is the <code>every</code> function</p>
<pre><code>fold([true, false, true])
  = true &amp;&amp; false &amp;&amp; true
  = false
fold([]) = true</code></pre>
<p>which checks if all elements in a list are true.</p>
<p>and for <code>(Bool, ||)</code> we get the <code>some</code> function</p>
<pre><code>fold([true, false, true])
  = true || false || true
  = true
fold([]) = false</code></pre>
<p>which checks if some element is true.</p>
<hr>
<p>Another two interesting examples of folds are the <code>head</code> and <code>last</code> functions that find the first and last element of a list respectively. These arise out of the semigroup operations <code>⨮</code> and <code>⨭</code> defined as.</p>
<pre><code>x ⨭ y = x
x ⨮ y = y</code></pre>
<p>which simply discard one of their arguments.</p>
<p><code>head</code> then is the function</p>
<pre><code>fold([x, y, z])
  = x ⨭ y ⨭ z
  = x</code></pre>
<p>and <code>last</code> is the function</p>
<pre><code>fold([x, y, z])
  = x ⨮ y ⨮ z
  = z</code></pre>
<p>Unfortunately we can not give meaning to the expression <code>fold([])</code>. This is because <code>⨮</code> and <code>⨭</code> define semigroups that are not monoids, so these functions err on the empty list. This illustrates the problem of working with semigroups only, when our domain of study are lists.</p>
<h3>
Algebra for parallelism
</h3>
<p>The relation of <code>folds</code> to the map-reduce programming model and parallel computation in general can be captured in the fact that they satisfy the following <em>distributive law</em>.</p>
<pre><code>fold(xs ++ ys) = fold(xs) ⊗ fold(ys)</code></pre>
<p>For a list that is the concatenation of lists <code>xs</code> and <code>ys</code>, <code>fold(xs)</code> and <code>fold(ys)</code> could be computed on different machines, or CPU cores, so such a law is a suitable condition for when a problem can be solved in a distributed or parallel way. At the end the two partial solutions are re-combined using the monoid composition <code>⊗</code>, and this law then states that this behaves <em>“as if the problem was solved sequentially”</em>, by folding the entire list in sequence.</p>
<p>Since <code>sum</code> and <code>maximum</code> are both folds, they can be computed in parallel. The distributive law is these cases become</p>
<pre><code>sum([1, 2, 3, 4, 5, 6])
  = sum([1, 2, 3] ++ [4, 5, 6])
  = sum([1, 2, 3]) + sum([4, 5, 6])

maximum([9, 6, 5, 12])
  = maximum([9, 6] ++ [5, 12])
  = maximum([9, 6]) `max` maximum([5, 12])</code></pre>
<p>Of course, such a law can be repeatedly applied</p>
<pre><code>sum([1, 2, 3, 4, 5, 6]) =
sum([1, 2]) + sum([3, 4, 5, 6]) =
sum([1, 2]) + sum([3, 4]) + sum([5, 6])</code></pre>
<p>to distribute such a problem to any number of machines or cores.</p>
<p>Note that the requirement for an identity element arises naturally out of such a law:</p>
<pre><code>fold(xs) = fold(xs ++ []) = fold(xs) ++ fold([])
fold(xs) = fold([] ++ xs) = fold([]) = fold(xs)</code></pre>
<p>the value <code>fold([])</code> must be such that it is an identity element for the range of <code>fold</code>, providing further evidence that the concept of a monoid is a natural extension of that of a semigroup when dealing with possibly empty lists.</p>
<p>The distributive law above is the fundamental property exploited in the map-reduce model, but <code>fold</code>s do <em>not</em> cover all functions that can be solved in this way. To provide a better classification we generalize.</p>
<h2 id="monoid-morphisms">Monoid morphisms</h2>
<p>To define the concept of a monoid morphism, we pair the distributive law mentioned above with <code>fold</code>s behaviour on the empty list, which by defintion returns the empty element of the target monoid.</p>
<pre><code>fold([]) = e
fold(xs ++ ys) = fold(xs) ⊗ fold(ys)</code></pre>
<p>We say that <code>fold</code>s <em>respects monoid structure</em>, because they map the identity element of lists (<code>[]</code>) to identity elements in their domains(<code>e</code>), and they map monoid compositions (<code>++</code>) to compositions in the target monoid (<code>⊗</code>).</p>
<p>A function that respects monoid structure is called a <strong>monoid morphism</strong>. Folds then, are monoid morphisms <em>from</em> the list monoid to another.</p>
<p>In general, monoid morphisms need not be from the list monoid. In general <code>h</code> is a monoid morphism if it satisfies</p>
<pre><code>h(e) = f
h(a ⊕ b) = h(a) ⊗ h(b)</code></pre>
<p>for some source monoid <code>(M, e, ⊕)</code> to a target monoid <code>(N, f, ⊗)</code>.</p>
<hr>
<p>As we have seen <code>sum</code> is a fold and thus a monoid morphism, in this case targetting the monoid of numbers with addition. Another morphism with the same target monoid is <code>length</code>. It is a monoid morphism as it also respects monoid structure.</p>
<pre><code>length([]) = 0
length(xs ++ ys) = length(xs) + length(ys)</code></pre>
<p>Length is of course also another example of a function that is computable in parallel (albeit not a very interesting one). It is not a <code>fold</code> however, and doesn’t even “type-check” as such.</p>
<hr>
<p>For some list, e.g. <code>[4, 6, 1]</code>, we can apply the distributive laws for <code>sum</code> and <code>length</code> over and over until we get to single-element lists.</p>
<pre><code>sum([4, 6, 1]) = sum([4]) + sum([6]) + sum([1])
length([4, 6, 1]) = length([4]) + length([6]) + length([1])</code></pre>
<p>We can always make an argument of this type. It must then be the case that the difference between <code>sum</code> and <code>length</code> is only really in how they behave on single-element lists.</p>
<pre><code>sum([x]) = x
length([x]) = 1</code></pre>
<p>As there is nothing special about <code>sum</code> or <code>length</code> we can generalize:</p>
<p><strong>Theorem</strong> A monoid morphism from lists is determined uniquely by its target monoid and its behaviour on single-element lists.</p>
<hr>
<p>A monoid morphism that both starts and ends in the list monoid, is <code>map(f)</code>, the higher-order function that maps a function <code>f</code> over each element of a list.</p>
<pre><code>map(f)([]) = []
map(f)(xs ++ ys) = map(f)(xs) ++ map(f)(ys)</code></pre>
<p><code>map(f)</code> is thus another parallelizable function, that also happen to be a monoid morphism. By our previous discussion, it also possible to define <code>map(f)</code> as the unique monoid morphism from lists to lists satisfying</p>
<pre><code>map(f)([x]) = [f(x)]</code></pre>
<p>Since any possible behaviour on single element lists can be expressed by some function <code>f</code>, we see that.</p>
<p><strong>Theorem</strong> Any monoid morphism from lists can be written on the form</p>
<pre><code>fold ∘ map(f)</code></pre>
<p>for some function <code>f</code>, clearly providing some validity to <em>Map-Reduce</em> as a computational model — it covers completely the set of functions “naturally” parallelizable through the distributive law defining monoid morphisms.</p>
<hr>
<p>There is a way to extend <em>any</em> semigroup <code>(S, ⊗)</code> into a monoid. We simply add to its underlying type another value, that we’ll call <code>None</code>. It’s composition will be the same as <code>⊗</code>, except for if either side is <code>None</code>, in which case we’ll make <code>None</code> an identity by defintion.</p>
<pre><code>None ⊗₊ x = x
x ⊗₊ None = x
x ⊗₊ y = x ⊗ y  // otherwise</code></pre>
<p>This construction is simply the <code>Option</code> or <code>Maybe</code> type, along with a suitably defined monoid structure.</p>
<p>Now we can define <code>safeHead</code> and <code>safeLast</code> as the folds of <code>⨭₊</code> and <code>⨮₊</code>. For instance <code>safeHead</code> is the fold</p>
<pre><code>fold([]) = None
fold([1, 2, 3])
  = 1 ⨭₊ 2 ⨭₊ 3
  = 1</code></pre>
<p>Creating “safe” functions on lists can be seen as correcting a mismatch in structure between lists (that are monoids), and semigroups (that are not).</p>
<p>The fact that we chose <code>maximum([]) = -Infinity</code> is a similar correction, in fact it is of exactly the same form, except we named <code>None</code> as <code>-Infinity</code>.</p>
<hr>
<p>Functions and maps are monoids if their domain is a monoid, where composition is performed pointwise.</p>
<pre><code>function composeFunctions(f,g) {
    return x =&gt; f(x) ⊗ g(x);
}</code></pre>
<p>we call this the pointwise lifting of the monoid over the range.</p>
<p>Frequency maps are an example of this construction, they are the pointwise lifted additive monoid on numbers <code>(Number, + 0)</code>.</p>
<p><strong>Exercise</strong> Consider the semigroup of the set <code>{ LESS, GREATER }</code> with composition <code>⨮</code>. Define the monoid of comparators starting with this semigroup, and using the <code>Option</code> and pointwise lifting constructions.</p>
<p><strong>Exercise</strong> Counting the votes in an election is a good real-word example of a parallelizable problem. Define a monoid morphism from a list of votes to some monoid giving the election results. Define the target monoid as the pointwise lift of another monoid.</p>
<p><strong>Exercise</strong> Show that the fundamental theorem of arithmetic induces a monoid morphism from <code>(Number, *, 1)</code> to the monoid <code>(Number, +, 0)</code> lifted pointwise over the prime numbers.</p>
]]></summary>
</entry>
<entry>
    <title>Algebraic patterns - Semigroup</title>
    <link href="http://philipnilsson.github.io/Badness10k//posts/2016-07-14-functional-patterns-semigroup.html" />
    <id>http://philipnilsson.github.io/Badness10k//posts/2016-07-14-functional-patterns-semigroup.html</id>
    <published>2016-07-14T00:00:00Z</published>
    <updated>2016-07-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on July 14, 2016
    
</div>

<h2 id="introduction">Introduction</h2>
<p>An important concept in functional programming is that of <em>composition</em>, where an aggregate or complex element can be described as the assembly of smaller parts.</p>
<p>Not all forms of composition are the same however. Consider the two problems</p>
<ol style="list-style-type: decimal">
<li>Assembling the pieces of a jigsaw-puzzle.</li>
<li>Assemble a piece of IKEA furniture from its parts.</li>
</ol>
<p>Putting puzzle pieces together and assembling furniture both involve composing smaller pieces into more complex, aggregate parts.</p>
<p>There is a difference between these two activities however, in that the assembly of furniture is highly linear and sequential. Generally it is necessary to start at the very first page of the manual, and following the instructions in order, from the first to the last.</p>
<p>Solving a puzzle is more freeform. Pieces from anywhere within it can be put together without enforcing any particlar order, like starting in the top left corner. This means solving a puzzle is easily parallelizable — simply enlist a friend to help solve a different part of the puzzle than yourself, and at any point combine the pieces from both efforts if possible.</p>
<p>Can we algebraically describe the difference between these two problems? It turns out that it is easy to do so, by introducing a simple requirement on the method of composition. The key observation is that composition of puzzle pieces satisfy the following rule.</p>
<p><img src="../images/puzzle-pieces.png" style="width: 60%"/></p>
<p>That is, given three puzzle pieces, these can be put together in two different ways, starting by combining the first and second, or staring with the second and third. Either way the final result is required to be the same.</p>
<p><img src="../images/pieces-composed.png" style="width: 60%"/></p>
<p>A method of composition satisfying the above constraint is said to be <em>associative</em>. For a larger set of puzzle pieces the associativity law can be repeatedly applied, until it is possible to make the statement that a jigsaw can be assembled in any order.</p>
<h2 id="definition">Definition</h2>
<p>A <strong>Semigroup</strong> is a data type together with a method of composition, ⊕, satisfying the associativity rule</p>
<pre><code>a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c</code></pre>
<h2 id="examples">Examples</h2>
<p>Numbers with addition are Semigroups, as well as numbers with multiplication, maximum and minimum. Note that this means that as with <a href="./2016-06-29-functional-patterns-identity-element.html">Identity elements</a>, the same datatype can have a given algebraic structure in multiple ways.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">a <span class="op">+</span> (b <span class="op">+</span> c) <span class="op">=</span> (a <span class="op">+</span> b) <span class="op">+</span> c
a <span class="op">*</span> (b <span class="op">*</span> c) <span class="op">=</span> (a <span class="op">*</span> b) <span class="op">*</span> c
<span class="at">max</span>(a<span class="op">,</span> <span class="at">max</span>(b<span class="op">,</span> c)) <span class="op">=</span> <span class="at">max</span>(<span class="at">max</span>(a<span class="op">,</span> b)<span class="op">,</span> c)
<span class="at">min</span>(a<span class="op">,</span> <span class="at">min</span>(b<span class="op">,</span> c)) <span class="op">=</span> <span class="at">min</span>(<span class="at">min</span>(a<span class="op">,</span> b)<span class="op">,</span> c)</code></pre></div>
<hr>
<p>Strings with string-concatenation form a semigroup. We write <code>++</code> for concatenation, so <code>&quot;foo&quot; ++ &quot;bar&quot;</code> is <code>&quot;foobar&quot;</code>. Clearly it holds that</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">a <span class="op">++</span> (b <span class="op">++</span> c) <span class="op">=</span> (a <span class="op">++</span> b) <span class="op">++</span> c</code></pre></div>
<p>Similarly, lists or arrays, with list/array-concatenation are semigroups. We write <code>++</code> also for this type of concatenation, so <code>[1, 2] ++ [3, 4, 5]</code> is <code>[1, 2, 3, 4, 5]</code></p>
<hr>
<p>The booleans are semigroups, with both <code>||</code> and <code>&amp;&amp;</code></p>
<pre><code>a &amp;&amp; (b &amp;&amp; c) = (a &amp;&amp; b) &amp;&amp; c
a || (b || c) = (a || b) || c</code></pre>
<hr>
<p>A very important associative operation is function composition. That is, for a triple of functions <code>f</code>, <code>g</code> and <code>h</code></p>
<pre><code>f ∘ (g ∘ h) = (f ∘ g) ∘ h</code></pre>
<p>Matrix multiplication is a binary operation that encodes the behaviour of composition of linear functions, and is thus also associative, making the set of <code>n</code>-by-<code>n</code> matrices a semigroup for any <code>n</code>.</p>
<hr>
<p>A <em>frequency map</em> is a map from values to “frequencies”, which are numbers intuitively representing the number of times a particular value has been “counted”. This is a natural way of modelling e.g. the outcome of an election. In an election with candidates <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code>, the results of counting the votes can be represented as a frequency map.</p>
<pre><code>{ A: 2, B: 4, C: 3, D: 1 }</code></pre>
<figcaption>
A frequency map example, where candidate <code>A</code> has 2 votes, <code>B</code> has 4 etc
</figcaption>
<p>The composition operation simply adds frequencies.</p>
<pre><code>addFrequencies({ A: 2, B: 1, C: 3 }, { B: 3, C: 1, D: 5 })
&gt;&gt; { A: 2, B: 4, C: 4, D: 5 }</code></pre>
<p>This operation is associative for all values. Notice that calculating the results of an election is a typical example of a parallelizable problem. No single person counts each vote in a large election, but rather results are aggregated first by district, the summarized into complete results. The fact that this is possible to do is neatly described algebraically by the associativity of the <code>addFrequencies</code> operation.</p>
<hr>
<p>Comparators are semigroups. A comparator is a function from two values to the set <code>{ LESS, EQUAL, GREATER }</code>. In Java and many other languages <code>LESS</code> is represented by any number &lt; <code>0</code>, <code>EQUAL</code> by <code>0</code> and <code>GREATER</code> by any number &gt; <code>0</code>, so that one can write</p>
<pre><code>function compareNumbers(i, j) {
    return i - j;
}</code></pre>
<p>The result of composing two comparators is a new comparator that compares by its parts in right-biased-order. For instance <code>firstNameComparator ⊕ lastNameComparator</code> is a comparator that compares first by <code>lastName</code> then by <code>firstName</code>.</p>
<pre><code>function composeComparators(c, d) {
   return (x, y) =&gt; {
      const comparisonResult = d(x, y);
      if (comparisonResult === EQUAL) {
        return c(x, y);
      }
      return comparisonResult;
   };
}</code></pre>
<p>As an exercise, check that comparator-composition is associative to verify that comparators for a semigroup.</p>
<hr>
<p>A “weird” associative operation is <code>⨮</code>, which is defined as</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">x ⨮ y <span class="op">=</span> y</code></pre></div>
<p>that is, it takes two arguments and discards the first. <em>Any</em> type is a semigroup paired with this operation.</p>
<p>Similary one can define <code>⨭</code> as the operation that discards its second argument, also forming the composition of a semigroup.</p>
<hr>
<p>Pairs of elements that are semigroups are semigroups with composition defined component-wise. For example <code>(4, &quot;foo&quot;) ⊕ (7, &quot;bar&quot;) = (11, &quot;foobar&quot;)</code> where we use the <code>+</code> semigroup on numbers and <code>++</code> on strings.</p>
<h2 id="applications">Applications</h2>
<p>The associativity condition is a suitable design goal in many situations, for the reason that it encodes the notion that the order of taking operations is irrelevant. Note that this is different from saying that the order of <em>elements</em> is important. For instance the expression <code>&quot;foo&quot; ++ &quot;bar&quot;</code> is not the same as <code>&quot;bar&quot; ++ &quot;foo&quot;</code>.</p>
<p>Complex behaviour described through associative composition is simpler and easier to understand, since the order of operations is not important.</p>
<p>A notable example in the javascript world that <em>fails</em> the associativity condition is the <code>.pipe</code> method in the <code>gulp</code> build system.</p>
<hr>
<p>The form of parallelism induced by the associativity of the semigroup operation is heavily relied upon in the <em>Map-Reduce</em> programming model. We’ll expound on this in more detail in a later article, as this is more easily developed algebraically after defining the concept of a <em>Monoid</em>.</p>
]]></summary>
</entry>
<entry>
    <title>Algebraic patterns - Identity element</title>
    <link href="http://philipnilsson.github.io/Badness10k//posts/2016-06-29-functional-patterns-identity-element.html" />
    <id>http://philipnilsson.github.io/Badness10k//posts/2016-06-29-functional-patterns-identity-element.html</id>
    <published>2016-06-29T00:00:00Z</published>
    <updated>2016-06-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on June 29, 2016
    
</div>

<h2 id="introduction">Introduction</h2>
<p>The pattern <strong>Identity element</strong> is all about defining the concept of <em>emptiness</em>, and is a good introduction to algebraically modelling programming concepts.</p>
<p>There are certain values — probably found scattered around the code you’re working on right now — values like the numbers <code>1</code> and <code>0</code>, the empty string <code>&quot;&quot;</code> or the empty array <code>[]</code>, that are often used as initializers and somehow feel “empty” or uninteresting.</p>
<p>The identity element pattern allows us to formalize this notion in a precise way, letting us explain just why these values are so common. That is, in a given code base, you’re probably more likely to see the string <code>&quot;&quot;</code>, than say, the string <code>&quot;banana&quot;</code>, and the number <code>0</code> more than the number <code>4279</code>. Is there some way we can explain what makes these values special?</p>
<hr>
<p>Imagine an empty glass. How can we define what it means for a glass to be empty? Now, of course, it is easy to do so informally, I just asked you to visualize one. But what is a formal property the empty glass satisfies, that non-empty glasses do not?</p>
<p>The key idea here will be to define an additional operation to <em>combine</em> two glasses. We will call this operation <strong>pour</strong>, and define it as taking two glasses and pouring their contents into a new identical container.</p>
<div class="figure">
<img src="../images/pour.png" />

</div>
<p>Equipped with this operation, we can find a property fulfilled by the empty glass and the empty glass alone: Pouring the contents of the empty glass into another glass leaves the other glass unchanged.</p>
<div class="figure">
<img src="../images/empty2.png" />

</div>
<p>and similarly, pouring the contents of any glass into the empty glass</p>
<div class="figure">
<img src="../images/empty1.png" />

</div>
<p>Formally, we can write this as the following pair of equations, where <code>x</code> represents any arbitrary glass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pour(emptyGlass, x) <span class="fu">=</span> x
pour(x, emptyGlass) <span class="fu">=</span> x</code></pre></div>
<h2 id="definition">Definition</h2>
<p>We can now take a look our other “empty” values, and check if they satisfy similar properties. And in fact, we will see that they do.</p>
<p>Take the number <code>0</code>. To say that <code>0</code> is in our sense empty, we will need to find an operation such that the equations above hold. We will take the operation <code>add</code>, which adds two numbers together, i.e. the operation such that <code>add(3, 9) = 12</code>. Now, it’s clear that</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">add</span>(<span class="dv">0</span><span class="op">,</span> x) <span class="op">=</span> x
<span class="at">add</span>(x<span class="op">,</span> <span class="dv">0</span>) <span class="op">=</span> x</code></pre></div>
<p>so the value <code>0</code> is in fact <em>empty</em> according to our definition. In particular we say that <code>0</code> is the identity element with respect to the addition operation.</p>
<hr>
<p>What about the empty array, or the empty string? We’ll kill two birds with one stone. Define the operation <code>concat</code>, such that <code>concat(&quot;foo&quot;, &quot;bar&quot;) = &quot;foobar&quot;</code>, and <code>concat([1,2,3], [4,5]) = [1,2,3,4,5]</code>. Then</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">concat</span>(<span class="st">&quot;&quot;</span><span class="op">,</span> x) <span class="op">=</span> x
<span class="at">concat</span>(x<span class="op">,</span> <span class="st">&quot;&quot;</span>) <span class="op">=</span> x</code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">concat</span>([]<span class="op">,</span> x) <span class="op">=</span> x
<span class="at">concat</span>(x<span class="op">,</span> []) <span class="op">=</span> x</code></pre></div>
<p>The empty array, and the empty string, are identity elements with respect to their concatenation operations, and so their emptiness can be formally described.</p>
<p>In general we say that for a set <code>A</code> with a closed binary operation ⊕, an empty (identity) element <code>e</code> is an element in <code>A</code> such that for all <code>x</code> in <code>A</code> we have</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">x ⊕ e <span class="op">=</span> x
e ⊕ x <span class="op">=</span> x</code></pre></div>
<h2 id="additional-examples">Additional Examples</h2>
<p>We could go on all day finding examples of identity elements, they are quite common, and there are plenty hiding in the wild. Let’s look at couple more.</p>
<p>First, let’s continue in the domain of numbers. We’ll take another special value: infinity, or <code>∞</code>. Infinity might seems like the opposite of “empty”, but it will turn out to be an example of an identity element. How exactly can we say that infinity is an empty element of the numbers?</p>
<p>To understand this, think of upper bounds. Let’s say I make the statement, <em>“The oldest person in the room is at most 80 years old”</em>. This means I claim to have some information about how old the people in the room are. But what if I had absolutely no clue? One way to express this could be saying <em>“The oldest person in the room is at most ∞ years old”</em>.</p>
<p>Infinity, seen as an <em>upper bound</em>, conveys no information, and is thus in this sense empty. What operation should we choose to express this notion? The answer is to use the <code>min</code> operator.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">min</span>(∞<span class="op">,</span> x) <span class="op">=</span> x<span class="op">;</span>
<span class="at">min</span>(x<span class="op">,</span> ∞) <span class="op">=</span> x<span class="op">;</span></code></pre></div>
<p><strong>Exercise</strong> Make a similar argument for negative infinity, and choose a suitable operation to prove it’s “emptiness”.</p>
<p>Note that this means that for a given domain, multiple empty objects may exist, with different choices of operators to give meaning to a specific sense of emptiness. Another value we can choose is <code>1</code> with the operation <code>mul</code>, such that <code>mul(5,3) = 15</code>.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">mul</span>(<span class="dv">1</span><span class="op">,</span> x) <span class="op">=</span> x<span class="op">;</span>
<span class="at">mul</span>(x<span class="op">,</span> <span class="dv">1</span>) <span class="op">=</span> x<span class="op">;</span></code></pre></div>
<p>This interpretation of emptiness is combinatorial in nature.</p>
<hr>
<p>Another important example is the <em>identity function</em>, <code>(x =&gt; x)</code>, or <code>id</code> as it’s often called. The identity function is the function that takes an input and returns it unchanged. That is <code>id(3) = 3</code>, or generally, <code>id(x) = x</code></p>
<p>What operation could we choose to see that this is an identity element? The operators we’re interested in are usually some natural way of composing two elements, so the answer of course, is to choose function composition: <code>(f, g) =&gt; x =&gt; f(g(x))</code>, or as it is often written, the operator ∘. We then get the equations</p>
<pre><code>f ∘ id = f
id ∘ f = f</code></pre>
<p>This simply states that to process either the input or the output of a function by applying the identity function is a no-op.</p>
<p>If you ever wondered where the identity function derives its name from, we see it is because it’s an identity element with respect to function composition <code>∘</code>.</p>
<h2 id="applications">Applications</h2>
<p>The key to making practical use of the identity element pattern is usually to simply recognize that such an element exists, or on occasion choosing a model so that such an element can be found, for instance using forests over trees.</p>
<p>Consider the build system <code>gulp</code>, where we can describe a build step to minify our code base in production mode only with the following definition.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">const</span> optimize <span class="op">=</span> <span class="va">env</span>.<span class="at">production</span>
    <span class="op">?</span> <span class="at">minify</span>()
    : <span class="va">util</span>.<span class="at">noop</span>()<span class="op">;</span>

<span class="va">gulp</span>.<span class="at">task</span>(<span class="st">&#39;build&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="cf">return</span> <span class="at">browserify</span>(source).<span class="at">pipe</span>(optimize)<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span></code></pre></div>
<p>We describe our optimization step as the stream processor <code>minify</code>, if our environment is configured to production, and to the identity element for the operation <code>pipe</code>, named <code>util.noop</code>, otherwise.</p>
<p>A no-op might seem like a useless build step, but we can see this code elegantly avoids awkward if-statements in the build task itself, delegating the responsibility of disabling optimizations to the optimization task.</p>
<p>If we were to design a build system ourselves, adding a no-op might not be an obvious inclusion, but equipped with understanding of the identity element pattern we can more easily identify its value.</p>
]]></summary>
</entry>
<entry>
    <title>A functional solution to Twitter's waterflow problem</title>
    <link href="http://philipnilsson.github.io/Badness10k//posts/2013-10-11-functional-waterflow.html" />
    <id>http://philipnilsson.github.io/Badness10k//posts/2013-10-11-functional-waterflow.html</id>
    <published>2013-10-11T00:00:00Z</published>
    <updated>2013-10-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on October 11, 2013
    
        by Philip Nilsson
    
</div>

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<p>I recently came across an interview question from Twitter at <a href="https://medium.com/@bearsandsharks/i-failed-a-twitter-interview-52062fbb534b#.tlspyu7h0">Michael Kozakov’s blog</a></p>
<p>After some thought I managed to boil this down to a simple functional one-liner I thought was interesting enough to share. First, let’s take a look at the problem definition.</p>
<p>Quoting the original source:</p>
<blockquote>
<p>“Consider the following picture:” <img src="../images/waterflow1.jpg"/></p>
</blockquote>
<blockquote>
<p>“In this picture we have walls of different heights. This picture is represented by an array of integers, where the value at each index is the height of the wall. The picture above is represented with an array as [2,5,1,2,3,4,7,7,6].”</p>
</blockquote>
<blockquote>
<p><img src="../images/waterflow2.jpg"/></p>
</blockquote>
<blockquote>
<p>“Now imagine it rains. How much water is going to be accumulated in puddles between walls?”</p>
</blockquote>
<blockquote>
<p>“We count volume in square blocks of 1x1. So in the picture above, everything to the left of index 1 spills out. Water to the right of index 7 also spills out. We are left with a puddle between 1 and 6 and the volume is 10.”</p>
</blockquote>
<p>How would we go about finding a solution to this problem? I find this to be especially interesting, as there were many solutions posted to this problem <a href="https://gist.github.com/mkozakov/59af0fd5bddbed1a0399">over here</a> that were incorrect. My own first intuition led me to a solution that didn’t cover all cases as well.</p>
<p>How can we analyze this problem such that we can get a solution and implementation that we can be confident is correct?</p>
<p>The approach I suggest would be to start with the question: “Given a block in this graph, when will it be filled with water?” We can assume there will be enough rain to fill any holes as far as is possible, so the only question is when the water will spill over to the side.</p>
<p>Then, the condition for the water to stay in a given square is that there is some wall to the <strong>left</strong> that is higher than the height of the given square, as well as some wall to the <strong>right</strong> that is higher that the height of the given square.</p>
<p>If we let \(h_i\) be the height of index \(i\), and let \(high_i^{left}\) denote the highest point to the left of index \(i\), and similarly define \(high_i^{right}\) we can express this as.</p>
<blockquote>
<p>A sqaure of height \(h_i\), is filled when \[ h_i \leq high_i^{left} h_i high_i^{right} \]</p>
</blockquote>
<p>We can simplify the conjunction by expressing this via \(min\)</p>
<p>\[ h_i \leq min(high_i^{left}, high_i^{right}) \]</p>
<p>We can now easily see that the height of the water level of each index, which we’ll call \(level_i\) can be expressed by turning this inequality into an equality.</p>
<p>\[ level_i = min(high_i^{left}, high_i^{right}) \]</p>
<p>This leaves us in good shape for actually computing the answer. We start by calculating the values if \(high\). Starting with \(high_i^{left}\) we note that this can be expressed as a simple recursive equation in terms of \(h\) and itself.</p>
<p>\[ high_0^{left} = h_0 \]</p>
<p>\[ high_{i+1}^{left} = max(h_{i+1} , high_i^{left}) \]</p>
<p>This a recursive relation, where we apply an operator <span class="math inline"><em>m</em><em>a</em><em>x</em></span> to accumulate values in the list <span class="math inline"><em>h</em></span>. We have a tool in the functional programming arsenal for computing exactly this, namely <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:scanl1"><em>scanl1</em></a>.</p>
<p>For e.g. the input <code>h = [2,5,1,2,3,4,7,7,6]</code> from the original post, we get</p>
<pre>scanl1 max h
>> [2,5,5,5,5,5,7,7,7]
</pre>
<p>Similarly for \( high_{right} \) we have</p>
<p>\[ high_n^{right} = h_n \]</p>
<p>\[ high_{i-1}^{right} = max(h_{i} , high_i^{left}) \]</p>
<p>And we can use <code>scanr1</code> to compute it</p>
<pre>scanr1 max h
>> [7,7,7,7,7,7,7,7,6]
</pre>
<p>Now getting back to \(level\), which, as we recall, was defined as</p>
<blockquote>
<p>\[ level_i = min(high_i^{left}, high_i^{right}) \]</p>
</blockquote>
<p>This is easy to compute, we only need to apply a function (\(min\)) element-wise, which we can do via an application of <code>zipWith</code></p>
<pre>zipWith min (scanl1 max h) (scanr1 max h)
>> [2,5,5,5,5,5,7,7,6]
</pre>
<p>Now we have defined the height of the water level at each index, all that is left is subtract the height of the “ground”, element-wise, to get the amount of water contributed at each index.</p>
<pre>let level h =
  zipWith min (scanl1 max h) (scanr1 max h)

zipWith (-) (level h) h
>> [0,0,4,3,2,1,0,0,0]
</pre>
<p>Now all that remains is taking the sum of the contributions at each index. This is, of course, as simple as applying the <code>sum</code> function.</p>
<p>Our complete implementation is now</p>
<pre>water h = sum $
  zipWith (-)
    (zipWith min (scanl1 max h) (scanr1 max h))
    h

water [2,5,1,2,3,4,7,7,6]
>> 10
</pre>
<p>We can now be confident that our implementation is correct. The breakdown of the problem corresponds nicely to our mathematical analysis, and our code is clean and declarative. The only price we have to pay is a linear use of extra space (arising from the use of <code>scanr1</code>), which is cleverly avoided in <a href="https://gist.github.com/mkozakov/59af0fd5bddbed1a0399">Michael Kozakov’s imperative solution</a>.</p>
]]></summary>
</entry>

</feed>
