<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BADNESS 10000</title>
    <atom:link href="http://localhost:8080/Badness10k/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://localhost:8080/Badness10k</link>
    <description>Exploring the world of software and functional programming, one compile error at a time.</description>
    <pubDate>Sat, 11 Jan 2014 01:00:00 +0100</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Patterns for Knockout.js — Proxy Object</title>
      <link>http://localhost:8080/Badness10k/Badness10k/articles/knockout-patterns-proxy/</link>
      <pubDate>Sat, 11 Jan 2014 01:00:00 +0100</pubDate>
      <guid isPermaLink="true">http://localhost:8080/Badness10k/Badness10k/articles/knockout-patterns-proxy/</guid>
      <author></author>
      <description>&lt;script src=&quot;/Badness10k/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/Badness10k/knockout.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/Badness10k/knockout-mapping.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Lately, I’ve been looking into patterns in Knockout that will allow
separation between view- and backend-related code. I’ve been trying to
find methods of transparently communicating to a server API when
relevant view model properties change, without explicitly concerning
the view code.&lt;/p&gt;
&lt;p&gt;I’m looking for “plain” knockout solutions, that doesn’t have to
involve the logic of some additional routing library, so we’ll focus
on using knockout’s main abstraction, observables.&lt;/p&gt;
&lt;p&gt;This post describes one of the solutions I’ve used for my current project,
which I will name proxy objects, lacking a better name. We’ll look
into how to set up observable objects that are automatically persisted
by posting to an API, and thus decoupling it from the view model.&lt;/p&gt;
&lt;p&gt;We’re going to build something like the example below, where the
server is notified as the user changes data in the fields. In the
right hand column we’ll log “server” (a.k.a console.log) calls to our
API. Edit the fields to see what calls are made.&lt;/p&gt;
&lt;div id=&quot;ex&quot; style=&quot;overflow: hidden; padding: 0.5em 0 1em 0&quot;&gt;
 &lt;div style=&quot;width: 34%; float: left; border: 1px solid lightgray; padding: 2%; font-size: 70%;&quot;&gt;
  &lt;div&gt; &lt;span style=&quot;width: 32%; display: inline-block;&quot;&gt;First name: &lt;/span&gt; &lt;input data-bind=&quot;value: firstName, valueUpdate: 'afterkeydown'&quot; /&gt; &lt;/div&gt;
  &lt;div&gt; &lt;span style=&quot;width: 32%; display: inline-block;&quot;&gt;Last name: &lt;/span&gt; &lt;input data-bind=&quot;value: lastName, valueUpdate: 'afterkeydown'&quot; /&gt; &lt;/div&gt;
  &lt;div&gt; &lt;span style=&quot;width: 32%; display: inline-block;&quot;&gt;Full name: &lt;/span&gt; &lt;input data-bind=&quot;value: fullName, valueUpdate: 'afterkeydown'&quot; /&gt; &lt;/div&gt;
  &lt;div&gt; &lt;span style=&quot;width: 32%; display: inline-block;&quot;&gt;SSN: &lt;/span&gt; &lt;input data-bind=&quot;value: ssn, valueUpdate: 'afterkeydown'&quot; /&gt; &lt;/div&gt;
 &lt;/div&gt;
 &lt;div id=&quot;ex_log&quot; style=&quot;width: 56%; height: 100%; float: right; border: 1px solid lightgray; padding: 2%; font-size: 70%;&quot;&gt;
    &amp;gt; Change the fields to see how the “API” is called.
 &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Note that we are ignoring the SSN field, as far as notifying the
backend goes. In this example we’ll assume the social security number
is a property that is not editable by the user, but I’ve included an
editable view for it as an example of a property changing on the view
model, without triggering a server call.&lt;/p&gt;
&lt;p&gt;We’re going to write a method &lt;code&gt;proxy&lt;/code&gt; that’ll allow us to set up the
code for this as follows.&lt;/p&gt;
&lt;pre&gt;
var person = {
  firstName: 'Steve',
  lastName: 'Sanderson',
  ssn: '1234',
  ignore: ['ssn']
};

ko.applyBindings(
  new ViewModel(
    ko.proxy('api/person', person)));
&lt;/pre&gt;

&lt;h2 id=&quot;implementing-proxy-&quot;&gt;Implementing &lt;code&gt;proxy&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Lets say we’ll start by retreiving the initial state from the server.&lt;/p&gt;
&lt;pre&gt;
$.get('api/person', function(init) {
  ...
})
&lt;/pre&gt;

&lt;p&gt;From here we can set up an observable that we could bind to the view,
using &lt;code&gt;ko.observable(init)&lt;/code&gt;. However, we’d like to react to changes in
any individual field (i.e. &lt;code&gt;firstName&lt;/code&gt; or &lt;code&gt;lastName&lt;/code&gt;). We can make all
fields of a javascript object observable by using the 
&lt;a href=&quot;http://knockoutjs.com/documentation/plugins-mapping.html&quot;&gt;knockout mapping plugin&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;
$.get('api/person', function(init) {
  var proxy = ko.mapping.fromJS(init);
})
&lt;/pre&gt;

&lt;p&gt;So how can we react to changes in any of the fields of this new
object? The result from ko.mapping is a javascript object with
observable fields, but it is not itself observable in its
entirety. Fortunately this can easily be solved by creating a computed
observable that uses the mapping-plugin’s reverse mapping
functionality that takes a mapped object to a plain javascript object.&lt;/p&gt;
&lt;pre&gt;
$.get('api/person', function(init) {
  var proxy = ko.mapping.fromJS(init);
  ko.computed(function() {
    console.log(ko.mapping.toJS(proxy));
  });
})
&lt;/pre&gt;

&lt;p&gt;Since the computed calls the reverse-mapping operation, it will
evalutate each observable in the proxy object, and thus each field
will be registered as a dependency, so we will now see logging to the
console whenever any individual field of the proxy is changed.&lt;/p&gt;
&lt;p&gt;Now all we need to do is to replace the &lt;code&gt;console.log&lt;/code&gt; logging with an
API call that calls the api. The only new source of complexity is that
we’d probably like to avoid to call our API directly after
initializing the first value, as we’d just send the same value back
anyway, so we keep track of that in variable &lt;code&gt;first&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;
$.get('api/person', function(init) {
  var proxy = ko.mapping.fromJS(init);
  var first = true;
  ko.computed(function() {
    var data = ko.mapping.toJS(proxy);
    if (!first) {
      $.ajax({
        type: 'post',
        url: '/api/person',
        data: { '': JSON.stringify(data) };
    }
    first = false;
  });
});
&lt;/pre&gt;

&lt;p&gt;If we clean this up a bit, putting code into some library function,
say &lt;code&gt;ko.proxy&lt;/code&gt;, we can set up our view model as&lt;/p&gt;
&lt;pre&gt;
$.get('api/person', function(init) {
  var proxy = ko.proxy('api/person', init);
  ko.applyBindings(new ViewModel(proxy));
})
&lt;/pre&gt;

&lt;p&gt;Note that we have a pretty good separation of concerns. The view model
does not have to know about server endpoints, or anything about the
API in order for changes to propagate to the server. It is however
necessary for the view model code to excercise some restraint in
updating the proxy object. For instance, if there is any validation to
be performed by the client, it’d be necessary to bind to another value
and perform validations on it before pushing changes to the proxy.&lt;/p&gt;
&lt;p&gt;In a future post I might give more examples on how we can easily
include this type of validation when using the proxy pattern.&lt;/p&gt;
&lt;h2 id=&quot;throttling&quot;&gt;Throttling&lt;/h2&gt;
&lt;p&gt;We’d probably like to perform some sort of throttling before sending
data to the server, so that we don’t perform an ajax call on
e.g. every single keystroke for a text input. We can do this easily
by applying knockout’s &lt;code&gt;throttle&lt;/code&gt; extensions (which really is a
debounce) on our computed observable.&lt;/p&gt;
&lt;pre&gt;
ko.computed(function() {
  var data = ko.mapping.toJS ( ... )
  ...
}).extend({ throttle: 1000 })
&lt;/pre&gt;

&lt;p&gt;That’s all we need to limit the rate of calls to when the user has
been inactive for one second.&lt;/p&gt;
&lt;h2 id=&quot;ignoring-fields&quot;&gt;Ignoring fields&lt;/h2&gt;
&lt;p&gt;It’s pretty common that the data available in a specific resource in
the API will contain data that we are not interested in sending back
to the server. Say our data contains another field for a social
security number &lt;code&gt;ssn&lt;/code&gt;. The ko.mapping plugin allows us to provide an
array containing fields we’d like to ignore when doing the reverse
mapping with &lt;code&gt;ko.mapping.toJS&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Our convention has been for the API itself to provide the list of
fields it’s not interested in updating, so a response might look
something like.&lt;/p&gt;
&lt;pre&gt;
{ 
  firstName: 'Ali',
  lastName: 'Pang',
  ssn: '1234',
  ignore: ['ssn']
}
&lt;/pre&gt;

&lt;p&gt;We now modify the &lt;code&gt;ko.proxy&lt;/code&gt; code to take this into account.&lt;/p&gt;
&lt;pre&gt;
ko.proxy = function (init, endpoint) {

    var ignoreAlways = ['ignore'];

    var obs = ko.mapping.fromJS(init, { ignore: ignoreAlways });

    var first = true;
    ko.computed(function () {
        var data = ko.mapping.toJS(obs, {
            ignore: init.ignore
        });
        if (!first)
            $.post({url: endpoint, data: { '': JSON.stringify(data) } });
        first = false;
    }).extend({
        throttle: 1400
    });
    return obs;
};
&lt;/pre&gt;

&lt;p&gt;We set things up so that the initial mapping via &lt;code&gt;fromJS&lt;/code&gt; ignore’s the
&lt;code&gt;ignore&lt;/code&gt; array, as this is not relevant for the view
model. Additionally, we tell &lt;code&gt;toJS&lt;/code&gt; to ignore the fields from
&lt;code&gt;init.ignore&lt;/code&gt;, which in this case would be &lt;code&gt;[&amp;#39;ssn&amp;#39;]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This will have two benefits.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We don’t send irrelevant data back to the server. In this example
we’re not using the &lt;code&gt;ssn&lt;/code&gt; to identify the user, it’s just an
unchangeable piece of extra data. With this setup, the &lt;code&gt;POST&lt;/code&gt; data
will not include the &lt;code&gt;ssn&lt;/code&gt; field on its way back to the server,
saving traffic.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Since the computed observable does not look at the ignored fields
when reverse mapping, any changes made by the view model to the
&lt;code&gt;ssn&lt;/code&gt; field will not trigger a server call, as it will not be
registered as a dependency.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In other words, if the view model calls &lt;code&gt;proxy.ssn(&amp;#39;4567&amp;#39;)&lt;/code&gt;, no call
will be made to the server. If it calls &lt;code&gt;proxy.name(&amp;#39;Philip&amp;#39;)&lt;/code&gt;, the
resulting post will not include data for the social security number.&lt;/p&gt;
&lt;h2 id=&quot;setting-up-the-view-model&quot;&gt;Setting up the view model&lt;/h2&gt;
&lt;p&gt;To complete this example, we can apply standard patterns, such as this
example, adding a full name property, from the knockout tutorial. It will
continue to work as expected.&lt;/p&gt;
&lt;pre&gt;
function ViewModel(proxy) {
    this.firstName = proxy.firstName;
    this.lastName = proxy.lastName;

    this.fullName = ko.computed({
        read: function () {
            return this.firstName() + &quot; &quot; + this.lastName();
        },
        write: function (value) {
            var lastSpacePos = value.lastIndexOf(&quot; &quot;);
            if (lastSpacePos &gt; 0) { 
                this.firstName(
                  value.substring(0, lastSpacePos));
                this.lastName(
                  value.substring(lastSpacePos + 1));
            }
        },
        owner: this
    });
}

ko.applyBindings(
  new ViewModel(
    ko.proxy('api/person', {
      firstName: 'Steve',
      lastName: 'Sanderson',
      ssn: '1234',
      ignore: ['ssn']
    })));
&lt;/pre&gt;

&lt;script&gt;

ko.proxy = function (init, endpoint) {

    var ignoreAlways = ['ignore'];

    var obs = ko.mapping.fromJS(init, { ignore: ignoreAlways });

    var first = true;
    ko.computed(function () {
        var data = ko.mapping.toJS(obs, {
            ignore: init.ignore
        });
        data = JSON.stringify(data);
        if (!first) {
            $('#ex_log').prepend('&lt;div&gt;' + '&amp;gt; Sending: ' + data + '&lt;/div&gt;');
            $('#ex_log div:gt(5)').remove()
        }
        first = false;
    }).extend({
        throttle: 1000
    });
    return obs;
};

function ViewModel(proxy) {
    this.firstName = proxy.firstName;
    this.lastName = proxy.lastName;
    this.ssn = proxy.ssn;

    this.fullName = ko.computed({
        read: function () {
            return this.firstName() + &quot; &quot; + this.lastName();
        },
        write: function (value) {
            var lastSpacePos = value.lastIndexOf(&quot; &quot;);
            if (lastSpacePos &gt; 0) { 
                this.firstName(
                  value.substring(0, lastSpacePos));
                this.lastName(
                  value.substring(lastSpacePos + 1));
            }
        },
        owner: this
    });
}

ko.applyBindings(
  new ViewModel(
    ko.proxy({
      firstName: 'Steve',
      lastName: 'Sanderson',
      ssn: '1234',
      ignore: ['ssn']
    })), document.getElementById('ex'));

&lt;/script&gt;</description>
    </item>
    <item>
      <title>A functional solution to Twitter's waterflow problem</title>
      <link>http://localhost:8080/Badness10k/Badness10k/articles/waterflow/</link>
      <pubDate>Fri, 11 Oct 2013 02:00:00 +0200</pubDate>
      <guid isPermaLink="true">http://localhost:8080/Badness10k/Badness10k/articles/waterflow/</guid>
      <author></author>
      <description>&lt;p&gt;I recently came across an interesting problem at &lt;a href=&quot;http://qandwhat.apps.runkite.com/i-failed-a-twitter-interview/&quot;&gt;Michael Kozakov’s
blog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are some interesting thoughts on the whole software interview
process over there. I don’t have much to add on the subject. However,
I thought the problem presented was quite interesting.&lt;/p&gt;
&lt;p&gt;After some thought I managed to boil this down to a simple functional
one-liner I though was interesting enough to share. First, let’s take
a look at the problem definition.&lt;/p&gt;
&lt;p&gt;Quoting the original source:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Consider the following picture:”
&lt;img src=&quot;http://qandwhat.apps.runkite.com/content/images/2013/Oct/twitter.jpg&quot; alt=&quot;Levels&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“In this picture we have walls of different heights. This picture is
represented by an array of integers, where the value at each index is
the height of the wall. The picture above is represented with an array
as [2,5,1,2,3,4,7,7,6].”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qandwhat.apps.runkite.com/content/images/2013/Oct/twitter_water.jpg&quot; alt=&quot;Filled&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“Now imagine it rains. How much water is going to be accumulated in
puddles between walls?”&lt;/p&gt;
&lt;p&gt;“We count volume in square blocks of 1x1. So in the picture above,
everything to the left of index 1 spills out. Water to the right of
index 7 also spills out. We are left with a puddle between 1 and 6 and
the volume is 10.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;How would we go about finding a solution to this problem? I find this
to be especially interesting, as there were many solutions posted to
this problem &lt;a href=&quot;https://gist.github.com/mkozakov/59af0fd5bddbed1a0399&quot;&gt;over
here&lt;/a&gt;, that
were incorrect. My own immediate intuition led me to a solution that
didn’t cover all cases as well.&lt;/p&gt;
&lt;p&gt;How can we analyze this problem such that we can get a solution and
implementation that we can be confident is correct?&lt;/p&gt;
&lt;p&gt;The approach I suggest would be to start with the question: “Given a
block in this graph, when will it be filled with water? We can assume
there will be enough rain to fill any holes as far as is possible, so the
only question is when the water will spill over to the side.&lt;/p&gt;
&lt;p&gt;Then, the condition for the water to stay in a given square is that
there is some wall to the &lt;strong&gt;left&lt;/strong&gt; that is at least as high as the height of the
given square, as well as some wall to the &lt;strong&gt;right&lt;/strong&gt; that is as high as
the height of the given square.&lt;/p&gt;
&lt;p&gt;If we let \(h_i\) be the height of index \(i\), and let
\(high_i^{left}\) denote the highest point to the left of index
\(i\), and similarly define \(high_i^{right}\) we can express this
as.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A sqaure of height \(h_i\), is filled when
\[ h_i \leq high_i^{left} \land h_i \leq high_i^{right} \]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can simplify the conjunction by expressing this via \(min\)&lt;/p&gt;
&lt;p&gt;\[ h_i \leq min(high_i^{left}, high_i^{right}) \]&lt;/p&gt;
&lt;p&gt;We can now easily see that the height of the water level of each
index, which we’ll call \(level_i\) can be expressed by turning this
inequality into an equality.&lt;/p&gt;
&lt;p&gt;\[ level_i = min(high_i^{left}, high_i^{right}) \]&lt;/p&gt;
&lt;p&gt;This leaves us in good shape for actually computing the answer. We
start by calculating the values of \(high\). Starting with \(high_i^{left}\) we note that
this can be expressed as a simple recursive equation in terms of \(h\) and itself.&lt;/p&gt;
&lt;p&gt;\[ high_0^{left} = h_0 \]&lt;/p&gt;
&lt;p&gt;\[ high_{i+1}^{left} = max(h_{i+1} , high_i^{left}) \] &lt;/p&gt;
&lt;p&gt;This a recursive relation, where we apply an operator (\(max\)) to
accumulate values in a list (\(h\)). We have a tool in the
functional programming arsenal for computing exactly this, namely
&lt;a href=&quot;http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:scanl1&quot;&gt;&lt;em&gt;scanl1&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For e.g. the input &lt;code&gt;h = [2,5,1,2,3,4,7,7,6]&lt;/code&gt; from the original post, we get&lt;/p&gt;
&lt;pre&gt;scanl1 max h 
&gt;&gt; [2,5,5,5,5,5,7,7,7]
&lt;/pre&gt;

&lt;p&gt;Similarly for \( high_{right} \) we have&lt;/p&gt;
&lt;p&gt;\[ high_n^{right} = h_n \]&lt;/p&gt;
&lt;p&gt;\[ high_{i-1}^{right} = max(h_{i} , high_i^{left}) \] &lt;/p&gt;
&lt;p&gt;And we can use &lt;code&gt;scanr1&lt;/code&gt; to compute it&lt;/p&gt;
&lt;pre&gt;scanr1 max h 
&gt;&gt; [7,7,7,7,7,7,7,7,6]
&lt;/pre&gt;

&lt;p&gt;Now getting back to \(level\), which, as we recall, was defined as&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;\[ level_i = min(high_i^{left}, high_i^{right}) \]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is easy to compute, we only need to apply a function (\(min\))
element-wise, which we can do via an application of &lt;code&gt;zipWith&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;zipWith min (scanl1 max h) (scanr1 max h)
&gt;&gt; [2,5,5,5,5,5,7,7,6]
&lt;/pre&gt;

&lt;p&gt;Now we have defined the height of the water level at each index, all
that is left is subtract the height of the “ground”, element-wise, to
get the amount of water contributed at each index.&lt;/p&gt;
&lt;pre&gt;let level h =
  zipWith min (scanl1 max h) (scanr1 max h)

zipWith (-) (level h) h
&gt;&gt; [0,0,4,3,2,1,0,0,0]
&lt;/pre&gt;

&lt;p&gt;Now all that remains is taking the sum of the contributions at each
index. This is, of course, as simple as applying the &lt;code&gt;sum&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Our complete implementation is now&lt;/p&gt;
&lt;pre&gt;water h = sum $ 
  zipWith (-) 
    (zipWith min (scanl1 max h) (scanr1 max h))
    h

water [2,5,1,2,3,4,7,7,6]
&gt;&gt; 10
&lt;/pre&gt;

&lt;p&gt;We can now be confident that our implementation is correct. The
breakdown of the problem corresponds nicely to our mathematical
analysis, and our code is clean and declarative. The only price we
have to pay is a linear use of extra space (arising from the use of
&lt;code&gt;scanr1&lt;/code&gt;), which is cleverly avoided in &lt;a href=&quot;https://gist.github.com/mkozakov/59af0fd5bddbed1a0399&quot;&gt;Michael Kozakov’s imperative
solution&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>