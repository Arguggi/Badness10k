<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Badness 10.000 - A functional solution to Twitter's waterflow problem</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/pandoc.css" />
    <link rel="alternate" type="application/rss+xml" href="http://philipnilsson.github.io/Badness10k/atom.xml" title="RSS feed for this page" />

  </head>
  <body>
    <div id="header">
      <div id="logo">
        <a href="../"><h2>BADNESS 10000</h2></a>
      </div>

      <a class="twitter-bird" href="//www.twitter.com/ali_pang">
         <img src="https://g.twimg.com/dev/documentation/image/Twitter_logo_blue_48.png" />
      </a>

    </div>

    <div id="content">
      <h1>A functional solution to Twitter's waterflow problem</h1>

      <div class="info">
    Posted on October 11, 2013
    
        by Philip Nilsson
    
</div>

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<p>I recently came across an interview question from Twitter at <a href="https://medium.com/@bearsandsharks/i-failed-a-twitter-interview-52062fbb534b#.tlspyu7h0">Michael Kozakov’s blog</a></p>
<p>After some thought I managed to boil this down to a simple functional one-liner I thought was interesting enough to share. First, let’s take a look at the problem definition.</p>
<p>Quoting the original source:</p>
<blockquote>
<p>“Consider the following picture:” <img src="../images/waterflow1.jpg" /></p>
</blockquote>
<blockquote>
<p>“In this picture we have walls of different heights. This picture is represented by an array of integers, where the value at each index is the height of the wall. The picture above is represented with an array as [2,5,1,2,3,4,7,7,6].”</p>
</blockquote>
<blockquote>
<p><img src="../images/waterflow2.jpg" /></p>
</blockquote>
<blockquote>
<p>“Now imagine it rains. How much water is going to be accumulated in puddles between walls?”</p>
</blockquote>
<blockquote>
<p>“We count volume in square blocks of 1x1. So in the picture above, everything to the left of index 1 spills out. Water to the right of index 7 also spills out. We are left with a puddle between 1 and 6 and the volume is 10.”</p>
</blockquote>
<p>How would we go about finding a solution to this problem? I find this to be especially interesting, as there were many solutions posted to this problem <a href="https://gist.github.com/mkozakov/59af0fd5bddbed1a0399">over here</a> that were incorrect. My own first intuition led me to a solution that didn’t cover all cases as well.</p>
<p>How can we analyze this problem such that we can get a solution and implementation that we can be confident is correct?</p>
<p>The approach I suggest would be to start with the question: “Given a block in this graph, when will it be filled with water?” We can assume there will be enough rain to fill any holes as far as is possible, so the only question is when the water will spill over to the side.</p>
<p>Then, the condition for the water to stay in a given square is that there is some wall to the <strong>left</strong> that is higher than the height of the given square, as well as some wall to the <strong>right</strong> that is higher that the height of the given square.</p>
<p>If we let \(h_i\) be the height of index \(i\), and let \(high_i^{left}\) denote the highest point to the left of index \(i\), and similarly define \(high_i^{right}\) we can express this as.</p>
<blockquote>
<p>A sqaure of height \(h_i\), is filled when \[ h_i \leq high_i^{left} h_i high_i^{right} \]</p>
</blockquote>
<p>We can simplify the conjunction by expressing this via \(min\)</p>
<p>\[ h_i \leq min(high_i^{left}, high_i^{right}) \]</p>
<p>We can now easily see that the height of the water level of each index, which we’ll call \(level_i\) can be expressed by turning this inequality into an equality.</p>
<p>\[ level_i = min(high_i^{left}, high_i^{right}) \]</p>
<p>This leaves us in good shape for actually computing the answer. We start by calculating the values if \(high\). Starting with \(high_i^{left}\) we note that this can be expressed as a simple recursive equation in terms of \(h\) and itself.</p>
<p>\[ high_0^{left} = h_0 \]</p>
<p>\[ high_{i+1}^{left} = max(h_{i+1} , high_i^{left}) \]</p>
<p>This a recursive relation, where we apply an operator <span class="math inline"><em>m</em><em>a</em><em>x</em></span> to accumulate values in the list <span class="math inline"><em>h</em></span>. We have a tool in the functional programming arsenal for computing exactly this, namely <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:scanl1"><em>scanl1</em></a>.</p>
<p>For e.g. the input <code>h = [2,5,1,2,3,4,7,7,6]</code> from the original post, we get</p>
<pre>scanl1 max h
>> [2,5,5,5,5,5,7,7,7]
</pre>
<p>Similarly for \( high_{right} \) we have</p>
<p>\[ high_n^{right} = h_n \]</p>
<p>\[ high_{i-1}^{right} = max(h_{i} , high_i^{left}) \]</p>
<p>And we can use <code>scanr1</code> to compute it</p>
<pre>scanr1 max h
>> [7,7,7,7,7,7,7,7,6]
</pre>
<p>Now getting back to \(level\), which, as we recall, was defined as</p>
<blockquote>
<p>\[ level_i = min(high_i^{left}, high_i^{right}) \]</p>
</blockquote>
<p>This is easy to compute, we only need to apply a function (\(min\)) element-wise, which we can do via an application of <code>zipWith</code></p>
<pre>zipWith min (scanl1 max h) (scanr1 max h)
>> [2,5,5,5,5,5,7,7,6]
</pre>
<p>Now we have defined the height of the water level at each index, all that is left is subtract the height of the “ground”, element-wise, to get the amount of water contributed at each index.</p>
<pre>let level h =
  zipWith min (scanl1 max h) (scanr1 max h)

zipWith (-) (level h) h
>> [0,0,4,3,2,1,0,0,0]
</pre>
<p>Now all that remains is taking the sum of the contributions at each index. This is, of course, as simple as applying the <code>sum</code> function.</p>
<p>Our complete implementation is now</p>
<pre>water h = sum $
  zipWith (-)
    (zipWith min (scanl1 max h) (scanr1 max h))
    h

water [2,5,1,2,3,4,7,7,6]
>> 10
</pre>
<p>We can now be confident that our implementation is correct. The breakdown of the problem corresponds nicely to our mathematical analysis, and our code is clean and declarative. The only price we have to pay is a linear use of extra space (arising from the use of <code>scanr1</code>), which is cleverly avoided in <a href="https://gist.github.com/mkozakov/59af0fd5bddbed1a0399">Michael Kozakov’s imperative solution</a>.</p>

    </div>
    <div id="footer">
      <a href="https://twitter.com/ali_pang" class="twitter-follow-button" data-show-count="false">Follow @ali_pang</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
      <div>Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></div>
      <a type="application/rss+xml" href="http://philipnilsson.github.io/Badness10k/atom.xml">RSS feed for this page</a>
    </div>
  </body>
</html>
