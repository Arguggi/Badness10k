<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Badness 10.000 - Algebraic patterns — Semigroup</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Badness 10.000</a>
                <a class="twitter-bird" href="//www.twitter.com/ali_pang">
                  <img src="https://g.twimg.com/dev/documentation/image/Twitter_logo_blue_48.png">
                </a>
            </div>
        </div>

        <div id="content">
            <h1>Algebraic patterns — Semigroup</h1>
            <div class="info">
    Posted on July 14, 2016
    
</div>

<h2 id="introduction">Introduction</h2>
<p>An important concept in functional programming is that of <em>composition</em>, where an aggregate or complex element can be described as the assembly of smaller parts.</p>
<p>Not all forms of composition are the same however. Consider the two problems</p>
<ol style="list-style-type: decimal">
<li>Assembling the pieces of a jigsaw-puzzle.</li>
<li>Assemble a piece of IKEA furniture from its parts.</li>
</ol>
<p>Putting puzzle pieces together and assembling furniture both involve composing smaller pieces into more complex, aggregate parts.</p>
<p>There is a difference between these two activities however, in that the assembly of furniture is highly linear and sequential. Generally it is necessary to start at the very first page of the manual, and following the instructions in order, from the first to the last.</p>
<p>Solving a puzzle is more freeform. Pieces from anywhere within it can be put together without enforcing any particlar order, like starting in the top left corner. This means solving a puzzle is easily parallelizable — simply enlist a friend to help solve a different part of the puzzle than yourself, and at any point combine the pieces from both efforts if possible.</p>
<p>Can we algebraically describe the difference between these two problems? It turns out that it is easy to do so, by introducing a simple requirement on the method of composition. The key observation is that composition of puzzle pieces satisfy the following rule.</p>
<div class="figure">
<img src="../images/puzzle-pieces.png" />

</div>
<p>That is, given three puzzle pieces, these can be put together in two different ways, starting by combining the first and second, or staring with the second and third. Either way the final result is required to be the same.</p>
<div class="figure">
<img src="../images/pieces-composed.png" />

</div>
<p>A method of composition satisfying the above constraint is said to be <em>associative</em>. For a larger set of puzzle pieces the associativity law can be repeatedly applied, until it is possible to make the statement that a jigsaw can be assembled in any order.</p>
<h2 id="definition">Definition</h2>
<p>A <strong>Semigroup</strong> is a data type together with a method of composition, ⊕, satisfying the associativity rule</p>
<pre><code>a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c</code></pre>
<h2 id="examples">Examples</h2>
<p>Numbers with addition are Semigroups, as well as numbers with multiplication, maximum and minimum. Note that this means that as with <a href="./2016-06-29-functional-patterns-identity-element.html">Identity elements</a>, the same datatype can have a given algebraic structure in multiple ways.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">a <span class="op">+</span> (b <span class="op">+</span> c) <span class="op">=</span> (a <span class="op">+</span> b) <span class="op">+</span> c
a <span class="op">*</span> (b <span class="op">*</span> c) <span class="op">=</span> (a <span class="op">*</span> b) <span class="op">*</span> c
<span class="at">max</span>(a<span class="op">,</span> <span class="at">max</span>(b<span class="op">,</span> c)) <span class="op">=</span> <span class="at">max</span>(<span class="at">max</span>(a<span class="op">,</span> b)<span class="op">,</span> c)
<span class="at">min</span>(a<span class="op">,</span> <span class="at">min</span>(b<span class="op">,</span> c)) <span class="op">=</span> <span class="at">min</span>(<span class="at">min</span>(a<span class="op">,</span> b)<span class="op">,</span> c)</code></pre></div>
<hr>
<p>Strings with string-concatenation form a semigroup. We write <code>++</code> for concatenation, so <code>&quot;foo&quot; ++ &quot;bar&quot;</code> is <code>&quot;foobar&quot;</code>. Clearly it holds that</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">a <span class="op">++</span> (b <span class="op">++</span> c) <span class="op">=</span> (a <span class="op">++</span> b) <span class="op">++</span> c</code></pre></div>
<p>Similarly, lists or arrays, with list/array-concatenation are semigroups. We write <code>++</code> also for this type of concatenation, so <code>[1, 2] ++ [3, 4, 5]</code> is <code>[1, 2, 3, 4, 5]</code></p>
<hr>
<p>The booleans are semigroups, with both <code>||</code> and <code>&amp;&amp;</code></p>
<pre><code>a &amp;&amp; (b &amp;&amp; c) = (a &amp;&amp; b) &amp;&amp; c
a || (b || c) = (a || b) || c</code></pre>
<hr>
<p>A very important associative operation is function composition. That is, for a triple of functions <code>f</code>, <code>g</code> and <code>h</code></p>
<pre><code>f ∘ (g ∘ h) = (f ∘ g) ∘ h</code></pre>
<p>Matrix multiplication is a binary operation that encodes the behaviour of composition of linear functions, and is thus also associative, making the set of <code>n</code>-by-<code>n</code> matrices a semigroup for any <code>n</code>.</p>
<hr>
<p>A <em>frequency map</em> is a map from values to “frequencies”, which are numbers intuitively representing the number of times a particular value has been “counted”. This is a natural way of modelling e.g. the outcome of an election. In an election with candidates <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code>, the results of counting the votes can be represented as a frequency map.</p>
<pre><code>{ A: 2, B: 4, C: 3, D: 1 }</code></pre>
<figcaption>
A frequency map example, where candidate <code>A</code> has 2 votes, <code>B</code> has 4 etc
</figcaption>
<p>The composition operation simply adds frequencies.</p>
<pre><code>addFrequencies({ A: 2, B: 1, C: 3 }, { B: 3, C: 1, D: 5 })
&gt;&gt; { A: 2, B: 4, C: 4, D: 5 }</code></pre>
<p>This operation is associative for all values. Notice that calculating the results of an election is a typical example of a parallelizable problem. No single person counts each vote in a large election, but rather results are aggregated first by district, the summarized into complete results. The fact that this is possible to do is neatly described algebraically by the associativity of the <code>addFrequencies</code> operation.</p>
<hr>
<p>Comparators are semigroups. A comparator is a function from two values to the set <code>{ LESS, EQUAL, GREATER }</code>. In Java and many other languages <code>LESS</code> is represented by any number &lt; <code>0</code>, <code>EQUAL</code> by <code>0</code> and <code>GREATER</code> by any number &gt; <code>0</code>, so that one can write</p>
<pre><code>function compareNumbers(i, j) {
    return i - j;
}</code></pre>
<p>The result of composing two comparators is a new comparator that compares by its parts in right-biased-order. For instance <code>firstNameComparator ⊕ lastNameComparator</code> is a comparator that compares first by <code>lastName</code> then by <code>firstName</code>.</p>
<pre><code>function composeComparators(c, d) {
   return (x, y) =&gt; {
      const comparisonResult = d(x, y);
      if (comparisonResult === EQUAL) {
        return c(x, y);
      }
      return comparisonResult;
   };
}</code></pre>
<p>As an exercise, check that comparator-composition is associative to verify that comparators for a semigroup.</p>
<hr>
<p>A “weird” associative operation is <code>⨮</code>, which is defined as</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">x ⨮ y <span class="op">=</span> y</code></pre></div>
<p>that is, it takes two arguments and discards the first. <em>Any</em> type is a semigroup paired with this operation.</p>
<p>Similary one can define <code>⨭</code> as the operation that discards its second argument, also forming the composition of a semigroup.</p>
<hr>
<p>Pairs of elements that are semigroups are semigroups with composition defined component-wise. For example <code>(4, &quot;foo&quot;) ⊕ (7, &quot;bar&quot;) = (11, &quot;foobar&quot;)</code> where we use the <code>+</code> semigroup on numbers and <code>++</code> on strings.</p>
<h2 id="applications">Applications</h2>
<p>The associativity condition is a suitable design goal in many situations, for the reason that it encodes the notion that the order of taking operations is irrelevant. Note that this is different from saying that the order of <em>elements</em> is important. For instance the expression <code>&quot;foo&quot; ++ &quot;bar&quot;</code> is not the same as <code>&quot;bar&quot; ++ &quot;foo&quot;</code>.</p>
<p>Complex behaviour described through associative composition is simpler and easier to understand, since the order of operations is not important.</p>
<p>A notable example in the javascript world that <em>fails</em> the associativity condition is the <code>.pipe</code> method in the <code>gulp</code> build system.</p>
<hr>
<p>The form of parallelism induced by the associativity of the semigroup operation is heavily relied upon in the <em>Map-Reduce</em> programming model. We’ll expound on this in more detail in a later article, as this is more easily developed algebraically after defining the concept of a <em>Monoid</em>.</p>

        </div>

        <div id="footer">
          <a href="https://twitter.com/ali_pang" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @ali_pang</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
          <div>
            <a type="application/rss+xml" href="http://philipnilsson.github.io/Badness10k/atom.xml">RSS feed for this page</a>
          </div>
        </div>

        <div id="disqus_thread"></div>
        <script>

          var disqus_config = function () {
            this.page.url = 'https://philipnilsson.github.io/Badness10k/posts/2016-07-14-functional-patterns-semigroup.html';
            this.page.identifier = 'Algebraic patterns — Semigroup';
          };

          (function() { // DON'T EDIT BELOW THIS LINE
          var d = document, s = d.createElement('script');
          s.src = 'https://badness-10-000.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </body>
</html>
