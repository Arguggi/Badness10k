<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Badness 10.000 - Algebraic patterns - Category</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/pandoc.css" />
    <link rel="alternate" type="application/rss+xml" href="http://philipnilsson.github.io/Badness10k/atom.xml" title="RSS feed for this page" />

  </head>
  <body>
    <div id="header">
      <div id="logo">
        <a href="../"><h2>BADNESS 10000</h2></a>
      </div>

      <a class="twitter-bird" href="//www.twitter.com/ali_pang">
         <img src="https://g.twimg.com/dev/documentation/image/Twitter_logo_blue_48.png" />
      </a>

    </div>

    <div id="content">
      <h1>Algebraic patterns - Category</h1>

      <div class="info">
    Posted on November  4, 2016
    
</div>

<h2 id="introduction">Introduction</h2>
<p>lul In our previous post on <a href="./2016-07-21-functional-patterns-monoid.html">Monoids</a> we’ve seen how to algebraically capture a notion of composition. In this post we’ll generalize Monoids into <strong>Categories</strong>.</p>
<p>One problem with modelling an idea with Monoids can be that they by necessity define composition for all available elements. This is not always suitable. For instance, while we have shown that functions can be composed as monoids — functions of the type <code>a -&gt; a</code> can be composed by function composition (<em>and functions on the type</em> <code>a -&gt; b</code> <em>where</em> <code>b</code> <em>is itself a monoid can be composed pointwise</em>) — this does not capture the general notion of function composition.</p>
<p>For instance, we might have a pair of functions <code>tokenize</code> and <code>parse</code>, that tokenizes and parses some language. Clearly it is sensible to talk about the composition <code>parse ∘ tokenize</code> that first tokenizes and the parses the language. It is also clearly <strong>not</strong> sensible to talk about the reverse composition <code>tokenize ∘ parse</code>, that first parses and then does tokenization.</p>
<p>The solution to this dilemma is to introduce some notion of <em>types</em> that determine when composition of two elements can be taken. Note that this is not related to whether a particular programming language offers type checking — our example above make no more sense in Clojure than it does in Haskell.</p>
<p>A category then intuitively is a Monoid with types. For each element we associate with it an “input type”, and an “output type”. The function <code>tokenize</code> will go perhaps from the type <code>String</code> to the type <code>List&lt;Token&gt;</code>, and the function <code>parse</code> might go from <code>List&lt;Token&gt;</code> to <code>AST</code>. We can take the composition of two elements <code>f ∘ g</code>, if the output of <code>f</code> matches the input of <code>g</code>, and so we are allowed to take the composition <code>parse ∘ tokenize</code> but not its reverse, as desired.</p>
<p>We will use the language of basic category theory to talk about these concepts</p>
<ul>
<li>What we have called a <em>type</em> is called an <strong>Object</strong> (probably somewhat confusing to many programmers).</li>
<li>A <em>function</em> is called a <strong>morphism</strong>.</li>
<li>An <em>“input type”</em> is called the <strong>domain</strong> of the morphism.</li>
<li>An <em>“output type”</em> is called the <strong>codomain</strong> of the morphism.</li>
<li>Composition, thankfully, is still called <strong>composition</strong> and is written <code>f ∘ g</code>.</li>
</ul>
<p>So there is a set of Objects, morphism between those Objects that can be composed if their types match. We also formulate something like the Monoid laws for Categories.</p>
<p>If the compsitions <code>f ∘ g</code> and <code>g ∘ h</code> are defined, then the compositions <code>f ∘ (g ∘ h)</code> and <code>(f ∘ g) ∘ h</code> are defined and equal <em>(<a href="../2016-07-14-functional-patterns-semigroup.html">associativity</a>)</em>.</p>
<p>For each Object there is an <strong>identity morphism</strong>, <code>id</code>, that satisfies <code>f ∘ id = f</code> and <code>id ∘ f = f</code> <em>(<a href="./2016-06-29-functional-patterns-identity-element.html">identity</a>)</em>.</p>

    </div>
    <div id="footer">
      <a href="https://twitter.com/ali_pang" class="twitter-follow-button" data-show-count="false">Follow @ali_pang</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
      <div>Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></div>
      <a type="application/rss+xml" href="http://philipnilsson.github.io/Badness10k/atom.xml">RSS feed for this page</a>
    </div>
  </body>
</html>
