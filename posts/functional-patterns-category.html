<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Badness 10.000 - Algebraic patterns — Category</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/pandoc.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Badness 10.000</a>
                <a class="twitter-bird" href="//www.twitter.com/ali_pang">
                  <img src="https://g.twimg.com/dev/documentation/image/Twitter_logo_blue_48.png">
                </a>
            </div>
        </div>

        <div id="content">
            <h1>Algebraic patterns — Category</h1>
            <div class="info">
    Posted on November  4, 2016
    
</div>

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<h2 id="introduction">Introduction</h2>
<p>In our previous post on <a href="./2016-07-21-functional-patterns-monoid.html">Monoids</a> we’ve seen how to algebraically capture a notion of composition. In this post we’ll generalize Monoids into <strong>Categories</strong>.</p>
<h2 id="functions">Functions</h2>
<p>The most obvious example driving the motivation for this generalization is <em>function composition</em>. Consider functions <span class="math inline"><em>p</em><em>a</em><em>r</em><em>s</em><em>e</em></span> and <span class="math inline"><em>t</em><em>o</em><em>k</em><em>e</em><em>n</em><em>i</em><em>z</em><em>e</em></span> that parses and tokenizes some language. Clearly it is sensible to take the composition <span class="math inline"><em>p</em><em>a</em><em>r</em><em>s</em><em>e</em> ∘ <em>t</em><em>o</em><em>k</em><em>e</em><em>n</em><em>i</em><em>z</em><em>e</em></span>, that first tokenizes and then parses the language. Equally clearly it’s no use taking the composition <span class="math inline"><em>t</em><em>o</em><em>k</em><em>e</em><em>n</em><em>i</em><em>z</em><em>e</em> ∘ <em>p</em><em>a</em><em>r</em><em>s</em><em>e</em></span> that first parses and <em>then</em> performs tokenization.</p>
<p>Monoids by necessity define composition of all available elements, so in order to generalize we’ll need to introduce some kind of constraints on when composition of elements is defined. In the case of functions, this notion corresponds to the idea of <em>types</em>.</p>
<p>Let’s say that our functions have types</p>
<p>\begin{aligned} tokenize &amp; :: String \rightarrow [Token] \\ parse &amp; :: [Token] \rightarrow AST \end{aligned}</p>
<p>meaning <span class="math inline"><em>t</em><em>o</em><em>k</em><em>e</em><em>n</em><em>i</em><em>z</em><em>e</em></span> takes a string and produces a list of tokens, and that <span class="math inline"><em>p</em><em>a</em><em>r</em><em>s</em><em>e</em></span> takes a list of tokens and produces and AST. The composition <span class="math inline"><em>p</em><em>a</em><em>r</em><em>s</em><em>e</em> ∘ <em>t</em><em>o</em><em>k</em><em>e</em><em>n</em><em>i</em><em>z</em><em>e</em></span> is well defined since the output type of <span class="math inline"><em>t</em><em>o</em><em>k</em><em>e</em><em>n</em><em>i</em><em>z</em><em>e</em></span> matches the input type of <span class="math inline"><em>p</em><em>a</em><em>r</em><em>s</em><em>e</em></span>. The opposite, <span class="math inline"><em>t</em><em>o</em><em>k</em><em>e</em><em>n</em><em>z</em><em>e</em> ∘ <em>p</em><em>a</em><em>r</em><em>s</em><em>e</em></span> does not have mathcing types, and so we need not bother trying to define the meaning of this expression.</p>
<p>The type of the composition is of course <span class="math inline"><em>S</em><em>t</em><em>r</em><em>i</em><em>n</em><em>g</em> → <em>A</em><em>S</em><em>T</em></span>.</p>
<p>We further note that function composition is associative. If we had an additional function \(assemble :: AST \rightarrow Assembly\), it is the case that</p>
<p>\[ assemble \circ (parse \circ tokenize) = (assemble \circ parse) \circ tokenize \]</p>
<p>We also note that there is a special set of <em>identity functions</em> for each type, \(id :: a \rightarrow a\), with the property that for any function <span class="math inline"><em>f</em></span> of suitable type</p>
<p>\[ f \circ id = id \circ f = f \]</p>
<p>While monoids have a single identity element, a category will have an identity function <em>per type</em>. That is, we consider the function \(id :: String \rightarrow String\) different from the function \(id :: Int \rightarrow Int\). If necessary one can write <span class="math inline"><em>i</em><em>d</em><sub><em>S</em><em>t</em><em>r</em><em>i</em><em>n</em><em>g</em></sub></span> and <span class="math inline"><em>i</em><em>d</em><sub><em>I</em><em>n</em><em>t</em></sub></span> to distinguish them, but usually it’s obvious from context which one is referred to.</p>
<h2 id="matrices">Matrices</h2>
<p>A very similar example comes from matrices, where the “types” correspond to matrix <em>dimensions</em>. Given matrices <span class="math inline"><em>M</em></span> of dimensions <span class="math inline">3 × 2</span>, and <span class="math inline"><em>N</em></span> of dimensions <span class="math inline">2 × 4</span>, the multiplication <span class="math inline"><em>M</em> × <em>N</em></span> is defined and have dimensions <span class="math inline">3 × 4</span>, but the product <span class="math inline"><em>N</em> × <em>M</em></span> is not defined.</p>
<p>We note that matrix multiplication is associative, i.e. \(M \times (N \times O) = (M \times N) \times O\) for any matrices with appropriate dimensions.</p>
<p>We also note that there is a special identity matrix <span class="math inline"><em>I</em></span>, for any dimension <span class="math inline"><em>n</em> × <em>n</em></span>, that satisfies</p>
<p>\[ I \times M = M \times I = M \]</p>
<p>for any matrix <span class="math inline"><em>M</em></span> with suitable dimensions. Again, unlike monoids there is no single identity matrix, but rather a different one of each “size”.</p>
<h2 id="monoid-morphisms">Monoid Morphisms</h2>
<p><a href="./2016-08-10-functional-patterns-monoid-morphism.html">Monoid morphisms</a> are also functions, and so form a category in that sense as long as their types match, (the target and source monoid of the morphism). However, in order to talk about the category of monoid morphism we have one more constraint: the composition of two monoid morphisms should itself be a monoid morphism. This turns out to be true, and for those interested we’ll verify it.</p>
<p>Given two monoid morphisms <span class="math inline"><em>h</em></span> — going from the monoid <span class="math inline">(<em>M</em>, ⊗<sub><em>M</em></sub>, <em>e</em><sub><em>M</em></sub>)</span> into <span class="math inline">(<em>N</em>, ⊗<sub><em>N</em></sub>, <em>e</em><sub><em>N</em></sub>)</span> — and <span class="math inline"><em>i</em></span> going from <span class="math inline">(<em>N</em>, ⊗<sub><em>N</em></sub>, <em>e</em><sub><em>N</em></sub>)</span> into <span class="math inline">(<em>O</em>, ⊗<sub><em>O</em></sub>, <em>e</em><sub><em>O</em></sub>)</span>, we’d like to prove first that the composition <span class="math inline"><em>i</em> ∘ <em>h</em></span> preserves identity. That is</p>
<p>\[ (i \circ h)(e_M) = i(h(e_M)) = i(e_N) = e_O \]</p>
<p><span class="math inline"><em>h</em></span> and <span class="math inline"><em>i</em></span> are monoid morphisms so they each preserve identity, and as a result so does their composition according to the calculation above. Additionally it preserves monoid composition</p>
<p>\begin{aligned} &amp; \quad (i \circ h)(a \otimes_M b) \\ = &amp; \quad i(h(a \otimes_M b)) \\ = &amp; \quad i(h(a) \otimes_N h(b)) \\ = &amp; \quad i(h(a)) \otimes_O i(h(b)) \\ = &amp; \quad (i \circ h)(a) \otimes_O (i \circ h)(b) \end{aligned}</p>
<h2 id="kleisli-categories">Kleisli Categories</h2>
<h3 id="the-maybe-category">The Maybe category</h3>
<p>Let’s say we have a function \(father :: Person \rightarrow Person\), that gives as output the father of the person taken as input. It’d make a lot of sense if we could use function composition to define the following function</p>
<p>\[ grandfather = father \circ father \]</p>
<p>This does indeed work, but it doesn’t really make sense that we could implement the <span class="math inline"><em>f</em><em>a</em><em>t</em><em>h</em><em>e</em><em>r</em></span> function as stated above. After all, we could also define</p>
<p>\[ greatGrandfather = father \circ grandfather \]</p>
<p>…and so on. We couldn’t reasonable expect to continue making such definitions indefinitely, as at some point we’d have to run out of information about a person’s paternal lineage. It’d make more sense if we had a function \(father :: Person \rightarrow Maybe \: Person \).</p>
<p>By using the type <span class="math inline"><em>M</em><em>a</em><em>y</em><em>b</em><em>e</em></span> we mean the option type, so that such a function may or may not return a value, in which case it returns the value <code>Nothing</code>.</p>
<p>We now run into a problem however, as we can not make the definition <span class="math inline"><em>g</em><em>r</em><em>a</em><em>n</em><em>d</em><em>f</em><em>a</em><em>t</em><em>h</em><em>e</em><em>r</em></span> with function composition as above, since the types don’t match up. We can however define a new composition function we’ll refer to as \(\circ_?\).</p>
<p>We’ll then define</p>
<p>\[ \begin{aligned} father &amp; :: Person \rightarrow Maybe \: Person \\ grandFather &amp; :: Person \rightarrow Maybe \: Person \\ grandFather &amp; = father \circ_? father \end{aligned} \]</p>
<p>The way \(\circ_?\) works is roughly to apply its first function, then to apply its second function if a value was produced by the first, otherwise it’ll return <code>Nothing</code>. Here’s a Haskell and Javascript implementation</p>
<pre>
f ∘<sub>?</sub> g = maybe Nothing f ∘ g

const none = {};
const some = x => ({ value: x });
function composeMaybe(f, g) {
   return function(x) {
       const result_g = g(x);
       if (result_g !== none)
           return f(result_g.value);
       return none;
   };
}
</pre>
<h3 id="the-list-category">The List category</h3>
<p>Let’s say we have a simliar defintion to the above that returns the parents of a person. We can model this as returning a list.</p>
<p>\[ parents :: Person \rightarrow [Person] \]</p>
<p>It’d be sensible to have some notion of compostion, we’ll call it \(\circ_{*}\), that lets us make the definition</p>
<p>\[ grandParents = parents \circ_{*} parents \]</p>
<p>We can easily provide such a composition function, here’s one again in Haskell and Javascript</p>
<pre>
f ∘<sub>*</sub> g = concat ∘ map f ∘ g

function composeList(f, g) {
    return function(x) {
        return [].concat(...g(x).map(f));
    };
}
</pre>
<h3 id="the-future-category">The Future category</h3>
<p>Now let’s say we have a genealogy API with a function <span class="math inline"><em>f</em><em>a</em><em>t</em><em>h</em><em>e</em><em>r</em></span> that we’d like to call in order to define the <span class="math inline"><em>g</em><em>r</em><em>a</em><em>n</em><em>d</em><em>F</em><em>a</em><em>t</em><em>h</em><em>e</em><em>r</em></span> function.</p>
<p>Again, standard function composition will not be enough, as we’ll now have to return some kind of representation of a value that’ll be available in the future.</p>
<p>\[ father :: Person \rightarrow Future \: Person \]</p>
<p>We’ll need a composition operator \(\circ_F\) that composes this type of functions. We’ll provide one in Javascript using Promises.</p>
<pre>
function composeFutures(f, g) {
    return function(x) {
        return f(x).then(g);
    };
}
</pre>
<p>In Haskell we might use the <code>Cont</code> type or some other suitable abstraction. We can now define the function that finds a Person’s grandfather by two successive API-calls with the definition</p>
<p>\[ grandFather = father \circ_F father \]</p>
<h3 id="kleisli-categories-1">Kleisli categories</h3>
<p>Functions that compose in the way we’ve seen above are all examples of Kleisli categories, and the different types, <span class="math inline"><em>M</em><em>a</em><em>y</em><em>b</em><em>e</em></span>, <span class="math inline">[]</span> and <span class="math inline"><em>F</em><em>u</em><em>t</em><em>u</em><em>r</em><em>e</em></span> are called <span class="math inline"><em>M</em><em>o</em><em>n</em><em>a</em><em>d</em><em>s</em></span>.</p>
<p>In order for these to really be examples of categories we must verify that these new composition operators behave like regular function composition in that they need to have identities and need to be associative. The associativity condition is expressed as</p>
<p>\[ (f \circ_? g) \circ_? h = f \circ?_ (g \circ_? h) \\ (f \circ_* g) \circ_* h = f \circ_* (g \circ_* h) \\ (f \circ_F g) \circ_F h = f \circ_F (g \circ_F h) \\ \]</p>
<p>for any functions <span class="math inline"><em>f</em></span>, <span class="math inline"><em>g</em></span> and <span class="math inline"><em>h</em></span> with the appropriate types.</p>
<p>We won’t prove that these hold, but you can try to verify it for each operation respectively if you’re interested.</p>
<p>There also need to be identities <span class="math inline"><em>i</em><em>d</em><sub>?</sub></span>, <span class="math inline"><em>i</em><em>d</em><sub>*</sub></span> and <span class="math inline"><em>i</em><em>d</em><sub><em>F</em></sub></span> that each satisfy.</p>
<p>\[ \begin{aligned} id_? \circ_? f = f &amp; &amp; f \circ_? id_? = f\\ id_* \circ_* f = f &amp; &amp; f \circ_* id_* = f\\ id_F \circ_F f = f &amp; &amp; f \circ_F id_F = f \end{aligned} \]</p>
<p>for any function <span class="math inline"><em>f</em></span>. We’ll provide examples in Haskell and Javascript.</p>
<pre>
id<sub>?</sub> x = Just x
id<sub>*</sub> x = [x]

function idMaybe(x) {
    return { value: x };
}

function idList(x) {
    return [x];
}

function idPromise(x) {
    return Promise.of(x);
}
</pre>
<p>You can try verify that these functions satisfy the rules for identity functions.</p>
<h2 id="monoids-as-categories">Monoids as categories</h2>
<p>We’ve had a look at the category of monoids and monoid morphisms, and so far all our examples has involved some kind of functions, except for matrices, but these are stand-ins for linear functions. We can however look at regular values in a monoid as the “functions” of a category. The trick is to assume there is only a single “type”. We can call it <code>()</code>. We can then take a monoid, let’s say the monoid of integers with addition, \((Integer, +, 0)\), and elements from that monoid, say the integers <span class="math inline">3</span> and <span class="math inline">12</span> and say they have types</p>
<p>\[ 3 :: \texttt{()} \rightarrow \texttt{()} \\ 12 :: \texttt{()} \rightarrow \texttt{()} \]</p>
<p>Having only a single type means composition of all elements is defined just like in a monoid, and the composition \(3 \circ 12\) is just <span class="math inline">3 + 12</span>. There will be an identity “function”</p>
<p>\[ 0 :: \texttt{()} \rightarrow \texttt{()} \]</p>
<p>satisfying the identity laws, and clearly the composition is also associative, so we are ok. All monoids then are categories by “erasing” the type information by using only a single “type” <code>()</code>.</p>
<h2 id="terminology">Terminology</h2>
<p>What we have described above as functions we will call <em>morphisms</em> (or sometimes <em>arrows</em>) and the types we’ll refer to as <em>objects</em>. (Unrelated to objects in the OOP sense). So a monoid is a category with a single object and the elements of the monoid as morphisms. Linear functions are categories with natural numbers as objects and matrices as morphisms. There is a category <code>Hask</code> is the category with Haskell functions as morphisms, and Haskell types as objects, etc.</p>
<p>Composition of morphisms should be associative and <em>has</em> to be defined whenever the types match. Also, for each object <span class="math inline"><em>A</em></span> there should be an identity morphism \(id_A :: A \rightarrow A\) satsifying the identity laws.</p>
<p>You can find a formal definition of categories <a href="https://en.wikiversity.org/wiki/Introduction_to_Category_Theory/Categories">here</a> and many other places.</p>
<h2 id="partial-orders">Partial orders</h2>
<p>We’ll finish off with another pair of examples of categories. We’ll introduce the <em>subtypes relation</em>. Let’s say we have three classes called <code>Person</code>, <code>Student</code> and <code>Teacher</code>. We’d like to express that both <code>Student</code> and <code>Teacher</code> are subtypes of <code>Person</code>. We’ll write this as follows.</p>
<p>\[ Student \leq: Person \\ Teacher \leq: Person \]</p>
<p>and we call \(\leq:\) the subtype relation. We write this relation similarly to the <span class="math inline">≤</span> relation. This is a subteltly that indicates that we wish to consider a class a subtype of itself. For instance</p>
<p>\[ Person \leq: Person \]</p>
<p>you can think of this as capturing the fact that both</p>
<pre><code>    (s :: Student) instanceof Person
    (p :: Person)  instanceof Person</code></pre>
<p>will evaluate to true.</p>
<p>The fact that we call \(\leq:\) a <em>partial</em> order means we will allow <code>Studen</code> and <code>Teacher</code> to be <em>incomparable</em>, meaning neither is smaller than the other.</p>
<p>\[ Student \nleq: Teacher \\ Teacher \nleq: Student \]</p>
<p>We can consider this a category by letting the objects be types, <code>Person</code>, <code>Student</code>, <code>Teacher</code> etc, and letting there be one single morphism between types if they satisfy the subtype relation. Since there is at most a single morphism between any two types (a type can not be a subtype of another in more than one way), we can name the single morphism between two types anything we like. We’ll use the name <span class="math inline"><em>s</em><em>u</em><em>b</em><em>s</em><em>u</em><em>m</em><em>e</em></span>.</p>
<p>\[ subsume_{(Student, Person)} :: Student \rightarrow Person \\ subsume_{(Teacher, Person)} :: Teacher \rightarrow Person \]</p>
<p>The laws of categories say that if we have an additional type <code>Professor</code> satisfying</p>
<p>\[ Professor \leq: Teacher \]</p>
<p>it must be the case that we have a morphism</p>
<p>\[ subsume_{(Professor, Teacher)} :: Professor \rightarrow Teacher \\ \]</p>
<p>and it must compose with morphisms of appropriate type so</p>
<p>\[ \begin{aligned} subsume_{(Professor, Person)} = \\ subsume_{(Teacher, Person)} &amp; \circ subsume_{(Professor, Teacher)} :: Professor \rightarrow Person \end{aligned} \]</p>
<p>so this law says a <code>Professor</code> must also be a <code>Person</code>, which of course is in alignment with what we mean by the subtype relationship.</p>
<p>There is also an identity morphism that says each type is a subtype of itself.</p>
<p>\[ id_a = subsume_{(a, a)} :: a \rightarrow a \]</p>
<p>Seen as a category, composition of <span class="math inline"><em>s</em><em>u</em><em>b</em><em>s</em><em>u</em><em>m</em><em>e</em></span> functions is obviously associative since there is exactly one morphism between types, and so they must be equal when defined.</p>
<p>In the next article we’ll talk about Functors, and will use this this category to let us talk about co- and contravariant type parameters in classes.</p>

        </div>

        <div id="footer">
          <a href="https://twitter.com/ali_pang" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @ali_pang</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
          <div>
            <a type="application/rss+xml" href="http://philipnilsson.github.io/Badness10k/atom.xml">RSS feed for this page</a>
          </div>
        </div>

        <div id="disqus_thread"></div>
        <script>

          var disqus_config = function () {
            this.page.url = 'https://philipnilsson.github.io/Badness10k/posts/functional-patterns-category.html';
            this.page.identifier = 'Algebraic patterns — Category';
          };

          (function() { // DON'T EDIT BELOW THIS LINE
          var d = document, s = d.createElement('script');
          s.src = 'https://badness-10-000.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </body>
</html>
